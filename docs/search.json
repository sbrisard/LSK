[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Notes on the Lyapunov–Schmidt–Koiter asymptotic method",
    "section": "",
    "text": "1 Welcome!\nThese are my notes on the LSK method for the analysis of the stability and bifurcation(s) of a conservative system. These notes are based on several references: the initial PhD thesis of Warner Tjardus Koiter (1945) as well as some graphical illustrations from his lecture notes (W. T. Koiter and Heijden 2009). I enjoyed the concise presentation of Nguyen (2000) as well as the lecture notes of Triantafyllidis (2017). Finally, the chapter by Potier-Ferry (1987) helped me clear some issues.\nThese notes by Sébastien Brisard are licensed under a Creative Commons Attribution 4.0 International License. To view a copy of this license, visit http://creativecommons.org/licenses/by/4.0/.\nI hope the reader will find these notes useful, even though there are still a few points which I do not fully understand (they are clearly indicated in the text).\n\n\n\n\n\n\n\nKoiter, W. T., and A. M. A. van der Heijden. 2009. W.T. Koiter’s Elastic Stability of Solids and Structures. Cambridge ; New York: Cambridge University Press.\n\n\nKoiter, Warner Tjardus. 1945. “The Stability of Elastic Equilibrium.” PhD thesis, Delft: Technische Hooge School Delft.\n\n\nNguyen, Quoc-Son. 2000. Stabilité et mécanique non linéaire. Paris: Hermès Science Publications.\n\n\nPotier-Ferry, Michel. 1987. “Foundations of Elastic Postbuckling Theory.” In Buckling and Post-Buckling, 1–82. Lecture Notes in Physics. Springer, Berlin, Heidelberg. https://doi.org/10.1007/BFb0009197.\n\n\nTriantafyllidis, Nicolas. 2017. “Stability of Solids: From Structures to Materials.” Lecture Notes. Palaiseau, France: École polytechnique."
  },
  {
    "objectID": "setting-up_the_mathematical_stage.html#sec-20230208081323",
    "href": "setting-up_the_mathematical_stage.html#sec-20230208081323",
    "title": "2  Setting-up the mathematical stage",
    "section": "2.1 Mathematical setting",
    "text": "2.1 Mathematical setting\nThe space of admissible states of the system under consideration is denoted \\(U\\). It has the structure of a real vector space. The energy of the system is \\(\\E(u, \\lambda)\\), where \\(\\lambda\\) denotes a loading parameter. It is assumed that the fundamental branch of the equilibrium diagram, \\(u^\\ast(\\lambda)\\) is known. Then the energy is stationary with respect to the state \\(u\\) along the whole branch. In other words, for all \\(\\hat{u} \\in U\\) \\[\n\\E_{,u}[u^{\\ast}(\\lambda), \\lambda; \\hat{u}]=0,\n\\tag{2.1}\\] where \\(\\E_{,u}(u, \\lambda; \\hat{u})\\) denotes the (real) value of the differential of the energy \\(\\E\\) with respect to the state \\(u\\), evaluated at \\((u, \\lambda)\\), for the test function \\(\\hat{u}\\). Similarly, evaluation of the second-, third-, etc., order differential of the energy will be denoted \\(\\E_{,uu}(u, \\lambda; \\hat{u}, \\hat{v})\\), \\(\\E_{,uuu}(u, \\lambda; \\hat{u}, \\hat{v}, \\hat{w})\\), etc. It is assumed that a finite value \\(\\lambda_0 > 0\\) of \\(\\lambda\\) can be found (critical load), such that\n\n\\(\\E_{,uu}[u(\\lambda), \\lambda] > 0\\) for all \\(0 < \\lambda < \\lambda_0\\),\n\\(\\E_{,uu}(u_0, \\lambda_0) \\geq 0\\) but \\(\\E_{,uu}(u_0, \\lambda_0) \\ngtr 0\\),\n\\(\\E_{,uu}[u(\\lambda), \\lambda] < 0\\) for \\(\\lambda > \\lambda_0\\), close enough to \\(\\lambda_0\\).\n\nThe load \\(\\lambda_0\\) will be referred to as the critical load; similarly, the state \\(u_0\\) of the system at the critical load will be referred to as the critical state; finally, the pair \\((u_0, \\lambda_0)\\) is the critical point of the system. Assumption 1 implies that equilibria along the fundamental branch are stable below the critical load. Conversely, it results from assumption 3 that equilibrium points on the fundamental branch are unstable above the critical load. Stability at the critical load is yet undetermined.\nThe goal of these notes is to analyze all equilibrium paths that pass through the critical point \\((u_0, \\lambda_0)\\).\nWe introduce the following notations \\[\nu_0 = u^\\ast(\\lambda_0), \\quad \\dot{u}_0 = \\frac{\\D u^\\ast}{\\D \\lambda} \\biggr \\rvert_{\\lambda=\\lambda_0}, \\quad \\ddot{u}_0 = \\frac{\\D^2 u^\\ast}{\\D \\lambda^2} \\biggr \\rvert_{\\lambda=\\lambda_0}, \\quad \\dddot{u}_0 = \\ldots, \\quad \\ddddot{u}_0 = \\ldots\n\\] and \\[\n\\E_2 = \\E_{,uu}(u_0, \\lambda_0), \\quad \\E_3 = \\E_{,uuu}(u_0, \\lambda_0), \\quad \\E_4 = \\E_{,uuuu}(u_0, \\lambda_0).\n\\]\nNote that \\(\\E_2\\), \\(\\E_3\\) and \\(\\E_4\\) thus defined are bi-, tri- and quadrilinear forms, respectively. The following derivatives are also introduced \\[\n\\dot{\\E}_2(\\hat{u}, \\hat{v}) = \\frac{\\D}{\\D\\lambda} \\E_{,uu}[ u^\\ast(\\lambda), \\lambda; \\hat{u}, \\hat{v}] \\biggr \\rvert_{\\lambda = \\lambda_0}\n= \\E_{,uuu}(u_0, \\lambda_0; \\dot{u}_0, \\hat{u}, \\hat{v}) + \\E_{,uu\\lambda}(u_0, \\lambda_0; \\hat{u}, \\hat{v})\n\\tag{2.2}\\] \\[\n\\begin{aligned}[b]\n\\ddot{\\E}_2(\\hat{u}, \\hat{v}) = \\frac{\\D^2}{\\D\\lambda^2} \\E_{,uu}[ u^\\ast(\\lambda), \\lambda; \\hat{u}, \\hat{v}] \\biggr \\rvert_{\\lambda = \\lambda_0}\n={} & \\E_{,uuuu}(u_0, \\lambda_0; \\dot{u}_0, \\dot{u}_0, \\hat{u}, \\hat{v}) + 2\\E_{,uuu\\lambda}(u_0, \\lambda_0; \\dot{u}_0, \\hat{u}, \\hat{v})\\\\\n& + \\E_{,uu\\lambda\\lambda}( u_0, \\lambda_0; \\hat{u}, \\hat{v}) + \\E_{,uuu}(u_0, \\lambda_0, \\ddot{u}_0),\n\\end{aligned}\n\\] and, similarly, \\(\\dot{\\E}_3\\), \\(\\ddot{\\E}_3\\), etc."
  },
  {
    "objectID": "setting-up_the_mathematical_stage.html#sec-20230107173921",
    "href": "setting-up_the_mathematical_stage.html#sec-20230107173921",
    "title": "2  Setting-up the mathematical stage",
    "section": "2.2 Kernel of the hessian of the energy",
    "text": "2.2 Kernel of the hessian of the energy\nThe kernel of the hessian of the energy, \\(\\E_2\\), is defined as follows \\[\nV = \\bigl\\{ u \\in U, \\E_2(u, u) = 0 \\bigr\\}.\n\\]\nSince \\(\\E_2\\) is a bilinear, symmetric and positive (but not poitive definite!) form, \\(V\\) is a vector subspace of \\(U\\).\nTo prove this result, we must show that, for all \\(u, v \\in V\\) and \\(\\alpha \\in \\reals\\), \\(w = u + \\alpha \\, v \\in V\\). From the bilinearity and symmetry of \\(\\E_2\\) \\[\n\\E_2(w, w) = \\E_2(u + \\alpha \\, v, u + \\alpha \\, v) = \\E_2(u, u) + 2\\alpha \\, \\E_2(u, v) + \\alpha^2 \\, \\E_2(v, v),\n\\]\nSince \\(u, v \\in \\ker\\E_2\\), the first and the last term vanish, and the above identity reduces to \\[\n\\E_2(w, w) = 2\\alpha \\, \\E_2(u, v)\n\\]\nThe bilinear form \\(\\E_2\\) is positive, therefore the left-hand side is positive, for all values of \\(\\alpha \\in \\reals\\). The quantity \\(\\E_2(u, v) = 0\\) is necessarily null, and \\(\\E_2(w, w) = 0\\), which proves that \\(w \\in V\\) and that \\(V\\) is a vector subspace of \\(U\\). The following characterization of \\(V\\) holds \\[\nv \\in V \\quad \\iff \\quad \\E_2(v, \\hat{u}) = 0 \\quad \\text{for all} \\quad \\hat{u} \\in U.\n\\tag{2.3}\\]\nIndeed, if for all \\(\\hat{u} \\in U\\), \\(\\E_2(v, \\hat{u}) = 0\\), then in particular \\(\\E_2(v, v) = 0\\) and \\(v \\in V\\). Conversely, let \\(v \\in V\\), \\(\\hat{u} \\in U\\) and \\(\\alpha \\in \\reals\\). Similarly to the previous proof, we write that \\(\\E_2(w, w) \\geq 0\\), with \\(w = \\hat{u} + \\alpha \\, v\\) \\[\n\\E_2(w, w) = \\E_2(\\hat{u}, \\hat{u}) + 2\\alpha \\, \\E_2(\\hat{u}, v) + \\alpha^2 \\, \\E_2(v, v) = 2\\alpha \\, \\E_2(\\hat{u}, v) + \\E_2(\\hat{u}, \\hat{u}) \\geq 0,\n\\] (\\(\\E_2(v, v) = 0\\) since \\(v \\in V\\)). The above expression is of degree 1 in \\(\\alpha\\), with a constant sign. Therefore the linear term in \\(\\alpha\\) must vanish: \\(\\E_2(\\hat{u}, v) = 0\\), which proves the characterization (2.3) of \\(V\\).\nIt will be assumed in the remainder of these notes the dimension of \\(V\\) is finite: \\(m = \\dim V < +\\infty\\); \\(m\\) is the multiplicity of the critical point. A (finite) basis \\((v_1, \\ldots, v_m)\\) of \\(V\\) can therefore be introduced, that is orthonormal in the sense of \\(\\langle \\bullet, \\bullet \\rangle\\) \\[\n\\langle v_i, v_j \\rangle = \\delta_{ij} \\quad \\text{for all} \\quad i, j = 1, \\ldots, m.\n\\]\nTo close this section, we define the complementary subspace \\(W\\), orthogonal to \\(V\\) for the scalar product \\(\\langle \\bullet, \\bullet \\rangle\\) \\[\nU = V \\overset{\\perp}{\\otimes} W \\quad \\text{and} \\quad \\langle \\hat{v}, \\hat{w} \\rangle = 0 \\quad \\text{for all} \\quad \\hat{v} \\in V \\quad \\text{and} \\quad \\hat{w} \\in W.\n\\]"
  },
  {
    "objectID": "setting-up_the_mathematical_stage.html#two-canonical-variational-problems",
    "href": "setting-up_the_mathematical_stage.html#two-canonical-variational-problems",
    "title": "2  Setting-up the mathematical stage",
    "section": "2.3 Two canonical variational problems",
    "text": "2.3 Two canonical variational problems\nThe bilinear form \\(\\E_2\\) is elliptic over \\(W\\). Therefore, variational problems of the type: find \\(w \\in W\\) such that \\[\n\\E_2(w, \\hat{w})+\\ell(\\hat{w}) = 0 \\quad \\text{for all} \\quad \\hat{w} \\in W\n\\] are well-posed for any linear form \\(\\ell\\) over \\(W\\). In particular, for \\(\\ell=0\\), the unique solution to the variational problem \\[\n\\E_2(w, \\hat{w}) = 0 \\quad \\text{for all} \\quad \\hat{w} \\in W\n\\] is \\(w = 0\\). For \\(\\ell(\\bullet) = \\E_3(v_i, v_j, \\bullet)\\) and \\(\\ell(\\bullet) = \\dot{\\E}_2(v_i, \\bullet),\\) \\(w_{ij} \\in W\\) and \\(w_{i\\lambda} \\in W\\) are defined as the unique solutions in \\(W\\) of the following variational problems \\[\n\\E_2(w_{ij}, \\hat{w}) + \\E_3(v_i, v_j, \\hat{w}) = 0\n\\tag{2.4}\\] and \\[\n\\E_2(w_{i\\lambda}, \\hat{w}) + \\dot{\\E}_2(v_i, \\hat{w}) = 0,\n\\tag{2.5}\\] for all \\(\\hat{w} \\in W\\). These variational problems (and their solutions) will pop-up recurrently in what follows."
  },
  {
    "objectID": "setting-up_the_mathematical_stage.html#sec-20230528173310",
    "href": "setting-up_the_mathematical_stage.html#sec-20230528173310",
    "title": "2  Setting-up the mathematical stage",
    "section": "2.4 Additional symbols",
    "text": "2.4 Additional symbols\nWe will make use of the following symbols \\[\n\\dot{E}_{ij} = \\dot{\\E}_2(v_i, v_j),\n\\tag{2.6}\\] \\[\n\\ddot{E}_{ij} = \\ddot{\\E}_2(v_i, v_j) + \\dot{\\E}_2(v_i, w_{j\\lambda}) + \\dot{\\E}_2(v_j, w_{i\\lambda}),\n\\tag{2.7}\\] \\[\nE_{ijk} = \\E_3(v_i, v_j, v_k),\n\\tag{2.8}\\] \\[\n\\dot{E}_{ijk} = \\dot{\\E}_3(v_i, v_j, v_k) + \\dot{\\E}_2(v_i, w_{jk}) + \\dot{\\E}_2(v_j, w_{ik}) + \\dot{\\E}_2(v_k, w_{ij}),\n\\tag{2.9}\\] \\[\n\\begin{aligned}[b]\nE_{ijkl} ={}& \\E_4(v_i, v_j, v_k, v_l) + \\E_3(v_i, v_j, w_{kl})\\\\\n&+ \\E_3(v_i, v_k, w_{jl}) + \\E_3(v_i, v_l, w_{jk}).\n\\end{aligned}\n\\tag{2.10}\\]\nThese symbols define second, third and fourth-order, fully symmetric, tensors over \\(V\\).\n\n\n\n\n\n\nConsistency of the above definitions\n\n\n\nSince \\(\\E_2(v, \\bullet) = 0\\) for all \\(v \\in V\\), definitions (2.6) and (2.8) of \\(\\dot{E}_{ij}\\) and \\(E_{ijk}\\) can also be written \\[\n\\dot{E}_{ij} = \\dot{\\E}_2(v_i, v_j) + \\E_2(v_i, w_{j\\lambda}) + \\E_2(v_j, w_{i\\lambda})\n\\] and \\[\nE_{ijk} = \\E_3(v_i, v_j, v_k)  + \\E_2(v_i, w_{jk}) + \\E_2(v_j, w_{ik}) + \\E_2(v_k, w_{ij}),\n\\] wich shows the consistency with definitions (2.7) and (2.9) of \\(\\ddot{E}_{ij}\\) and \\(\\dot{E}_{ijk}\\)."
  },
  {
    "objectID": "main_results.html",
    "href": "main_results.html",
    "title": "3  Perfect system: outline of the main results",
    "section": "",
    "text": "This document uses \\(\\LaTeX\\newcommand{\\D}{\\mathrm{d}}\\newcommand{\\E}{\\mathcal{E}}\\newcommand{\\order}[2][1]{#2^{(#1)}}\\newcommand{\\reals}{\\mathbb{R}}\\) custom macros.\nIt is shown in Chapter 5 that, besides the fundamental branch \\(u^\\ast(\\lambda)\\), other (bifurcated) equilibrium branches may pass through the critical point \\((u_0, \\lambda_0)\\). The bifurcated branch is a curve \\((u, \\lambda) \\in \\reals ^ {m + 1}\\). Introducing the (yet unspecified) parameter \\(\\eta\\), we introduce the following parametric representation of the bifurcated branch: \\(\\eta \\mapsto [u(\\eta), \\lambda(\\eta)]\\), with \\(u(0) = u_0\\) and \\(\\lambda(0) = \\lambda_0\\). The following asymptotic expansion of \\(\\eta \\mapsto \\lambda(\\eta)\\) and \\(\\eta \\mapsto u(\\eta)\\) are derived in Chapter 5 \\[\n\\lambda(\\eta) = \\order[0]{\\lambda} + \\eta \\, \\order[1]{\\lambda} + \\tfrac{1}{2}\\eta^2 \\, \\order[2]{\\lambda} \\quad \\text{and} \\quad u(\\eta) = u^\\ast[\\lambda(\\eta)] + \\eta \\, \\order[1]{u} + \\tfrac{1}{2} \\eta^2 \\, \\order[2]{u} + o(\\eta^2),\n\\tag{3.1}\\] with \\[\n\\order[1]{u} = \\order[1]{\\xi_i} \\, v_i\n\\quad \\text{and} \\quad\n\\order[2]{u} = \\order[2]{\\xi_i} \\, v_i + \\order[1]{\\xi_i} \\, \\order[1]{\\xi_j} \\, w_{ij}  + 2\\order[1]{\\lambda} \\, \\order[1]{\\xi_i} \\, w_{i\\lambda}.\n\\tag{3.2}\\]\nThe coefficients \\(\\order[1]{\\lambda}\\), \\(\\order[2]{\\lambda}\\), \\(\\order[1]{\\xi}_i\\) and \\(\\order[2]{\\xi}_i\\) solve the following bifurcation equations \\[\n\\tfrac{1}{2} E_{ijk} \\, \\order[1]{\\xi_j} \\, \\order[1]{\\xi_k} + \\order[1]{\\lambda} \\, \\dot{E}_{ij} \\, \\order[1]{\\xi_j} = 0\n\\tag{3.3}\\] and \\[\n\\begin{aligned}[b]\n\\tfrac{1}{3} E_{ijkl} \\, \\order[1]{\\xi}_j \\, \\order[1]{\\xi}_k \\, \\order[1]{\\xi}_l\n+ \\order[1]{\\lambda} \\, \\bigl( \\dot{E}_{ijk} \\, \\order[1]{\\xi}_k + \\order[1]{\\lambda} \\, \\ddot{E}_{ij} \\bigr) \\, \\order[1]{\\xi}_j &\\\\\n+ \\bigl( E_{ijk} \\, \\order[1]{\\xi}_k + \\order[1]{\\lambda} \\, \\dot{E}_{ij} \\bigr) \\order[2]{\\xi}_j\n+ \\order[2]{\\lambda} \\, \\dot{E}_{ij} \\, \\order[1]{\\xi}_j & = 0,\n\\end{aligned}\n\\tag{3.4}\\] where \\(\\dot{E}_{ij}\\), \\(\\ddot{E}_{ij}\\), \\(E_{ijk}\\), \\(\\dot{E}_{ijk}\\) and \\(E_{ijkl}\\) have been defined in Chapter 2 (see Section 2.4).\nAlong the bifurcated branch, the energy can also be expanded (see Chapter 6) \\[\n\\begin{aligned}[b]\n\\E[u(\\eta), \\lambda(\\eta)] ={}& \\E[u^\\ast \\circ \\lambda(\\eta), \\lambda(\\eta)]\n+ \\tfrac{1}{6} \\eta^3 \\, \\order[1]{\\lambda} \\, \\order[1]{\\xi}_i \\, \\order[1]{\\xi}_j \\, \\dot{E}_{ij}\\\\\n&+ \\tfrac{1}{24} \\eta^4 \\, \\bigl\\{ E_{ijkl} \\, \\order[1]{\\xi}_i \\, \\order[1]{\\xi}_j \\, \\order[1]{\\xi}_k \\, \\order[1]{\\xi}_l + 4\\order[1]{\\lambda} \\, \\dot{E}_{ijk} \\, \\order[1]{\\xi}_i \\, \\order[1]{\\xi}_j \\, \\order[1]{\\xi}_k\\\\\n&+ 6 \\bigl[ \\bigl( \\order[1]{\\lambda} \\bigr)^2 \\, \\ddot{E}_{ij} + \\order[2]{\\lambda} \\, \\dot{E}_{ij} \\bigr] \\, \\order[1]{\\xi}_i \\, \\order[1]{\\xi}_j \\bigr\\}.\n\\end{aligned}\n\\tag{3.5}\\]\nFinally, the eigenvalues \\(\\alpha\\) and eigenvectors \\(x\\) of the hessian are expanded to second order in \\(\\eta\\) in Chapter 7 \\[\n\\alpha = \\order[0]{\\alpha} + \\eta \\, \\order[1]{\\alpha} + \\tfrac{1}{2}\\eta^2 \\, \\order[2]{\\alpha} + o(\\eta^2)\n\\quad \\text{and} \\quad\nx = \\order[0]{x} + \\eta \\, \\order[1]{x} + \\tfrac{1}{2}\\eta^2 \\, \\order[2]{x} + o(\\eta^2).\n\\]\nThe potentially unstable eigenmodes are necessarily such that \\(\\order[0]{\\alpha} = 0\\). In that case, \\[\n\\order[0]{x} = \\order[0]{\\chi}_j \\, v_j\n\\quad \\text{and} \\quad\n\\order[1]{x} = \\order[1]{\\chi}_j \\, v_j + \\order[1]{\\lambda} \\, \\order[0]{\\chi}_j \\, w_{j\\lambda} + \\order[0]{\\chi}_j \\, \\order[1]{\\xi}_k \\, w_{jk}\n\\] where the coefficients \\(\\order[1]{\\alpha}\\), \\(\\order[2]{\\alpha}\\), \\(\\order[0]{\\chi}_i\\) and \\(\\order[1]{\\chi}_i\\) solve the following equations \\[\n\\bigl( E_{ijk} \\, \\order[1]{\\xi_k} + \\order[1]\\lambda \\, \\dot{E}_{ij} \\bigr) \\, \\order[0]{\\chi_j} = \\order[1]\\alpha \\, \\order[0]{\\chi_i},\n\\tag{3.6}\\] and \\[\n\\begin{aligned}\n\\bigl[ E_{ijkl} \\, \\order[1]{\\xi}_k \\, \\order[1]{\\xi}_l + \\order[1]{\\lambda} \\, \\bigl( 2\\dot{E}_{ijk} \\, \\order[1]{\\xi}_k + \\order[1]{\\lambda} \\, \\ddot{E}_{ij} \\bigr)+ E_{ijk} \\, \\order[2]{\\xi}_k + \\order[2]{\\lambda} \\, \\dot{E}_{ij} \\bigr] \\order[0]{\\chi}_j &\\\\\n+ 2\\bigl( E_{ijk} \\, \\order[1]{\\xi}_k + \\order[1]{\\lambda} \\, \\dot{E}_{ij} \\bigr) \\, \\order[1]{\\chi}_j &= 2 \\order[1]{\\alpha} \\, \\order[1]{\\chi}_i + \\order[2]{\\alpha} \\, \\order[0]{\\chi}_i.\n\\end{aligned}\n\\tag{3.7}\\]"
  },
  {
    "objectID": "setting-up_the_computational_stage.html#sec-20230103084732",
    "href": "setting-up_the_computational_stage.html#sec-20230103084732",
    "title": "4  Setting-up the computational stage",
    "section": "4.1 Importing Sympy",
    "text": "4.1 Importing Sympy\nWe will use the Python library SymPy for symbolic mathematics and rely also on the IPython library (in particular, IPython.display.Math) for pretty \\(\\LaTeX\\) output. Some useful functions are defined in the lsk.py module, which will be systematically imported.\nWithout loss of generality, it will be assumed in all symbolic calculations that \\(\\lambda_0 = 0\\) and \\(u_0 = 0\\). The general case \\(\\lambda_0 \\neq 0\\) and \\(u_0 \\neq 0\\) is readily recovered through the substitution \\(\\lambda \\leftrightarrow \\lambda - \\lambda_0\\) and \\(u \\leftrightarrow u - u_0\\).\nThe following developments involve the energy \\((u, \\lambda) \\mapsto \\E(u, \\lambda)\\) and its differentials at the critical point \\((u_0, \\lambda_0)\\), as well as the fundamental path \\(\\lambda \\mapsto u^\\ast(\\lambda)\\) and its derivatives at \\(\\lambda = \\lambda_0\\). It will therefore be convenient to express \\(\\E\\) and \\(u^\\star\\) as Taylor expansions with respect to \\(u\\) and \\(\\lambda\\).\nWe start with the Taylor expansion of the energy \\(\\E\\). We define its differentials at the critical point. These differentials are stored in a dictionary. Values are indexed with the order of the differentials with respect to \\(u\\) and \\(\\lambda\\).\n\n\n\n\n\n\nNote\n\n\n\nIn the following code blocks, n is the total order of the differential, p is the order of the differential with respect to \\(u\\) and q = n - p is the order of the differential with respect to \\(\\lambda\\).\n\n\n\nfrom sympy import *\n\n\n\n\n\n\n\nWarning\n\n\n\nThe above statement is extremely poor practice. We need it as sympy.srepr automatically drops the namespace. For example\n\nimport sympy.abc\nsrepr(sympy.abc.a + sympy.abc.b)\n\n\"Add(Symbol('a'), Symbol('b'))\"\n\n\nTherefore, in order to eval strings produced by sympy.srepr, as will be done in subsequent chapters, we will need all SymPy object to live in the global namespace.\n\n\n\nimport lsk\n\nλ, u, v, u_hat, v_hat, w_hat = sympy.symbols(r\"\\lambda u v \\hat{u} \\hat{v} \\hat{w}\")\n\n\ndE = dict()\nfor n in range(1, 5):\n    for p in range(n + 1):\n        q = n - p\n        if q == 0:\n            dE[p, q] = Symbol(r\"\\E_{}\".format(p))\n        else:\n            dE[p, q] = Symbol(r\"\\E_{\" + p * \"u\" + q * \"\\lambda\" + \"}\")\n            \n# Remember that the energy is stationary at the critical point (equilibrium)\ndE[1, 0] = Number(0)\n\nThe dictionary dE should be understood as follows: dE[(2, 1)] == dE[2, 1] is the symbol \\(\\E_{uu\\lambda}\\), which stands for \\(\\E_{,uu\\lambda}(u_0, \\lambda_0; \\bullet, \\bullet)\\). The following symbols have been defined.\n\n\nCode\n_dict = dict()\nfor n in range(1, 5):\n    for p in range(n + 1):\n        q = n - p\n        _dict[dE[p, q]] = (\"\\\\E_{,\" + p * \"u\" \n                           + q * \"\\\\lambda\"\n                           + \"}(u_0, \\lambda_0)\")\n        \nlsk.display_latex_dict(_dict, num_cols=3)\n\n\n\\(\\displaystyle \\begin{align}\\E_{\\lambda}&=\\E_{,\\lambda}(u_0, \\lambda_0)&0&=\\E_{,u}(u_0, \\lambda_0)&\\E_{\\lambda\\lambda}&=\\E_{,\\lambda\\lambda}(u_0, \\lambda_0)\\\\\\E_{u\\lambda}&=\\E_{,u\\lambda}(u_0, \\lambda_0)&\\E_{2}&=\\E_{,uu}(u_0, \\lambda_0)&\\E_{\\lambda\\lambda\\lambda}&=\\E_{,\\lambda\\lambda\\lambda}(u_0, \\lambda_0)\\\\\\E_{u\\lambda\\lambda}&=\\E_{,u\\lambda\\lambda}(u_0, \\lambda_0)&\\E_{uu\\lambda}&=\\E_{,uu\\lambda}(u_0, \\lambda_0)&\\E_{3}&=\\E_{,uuu}(u_0, \\lambda_0)\\\\\\E_{\\lambda\\lambda\\lambda\\lambda}&=\\E_{,\\lambda\\lambda\\lambda\\lambda}(u_0, \\lambda_0)&\\E_{u\\lambda\\lambda\\lambda}&=\\E_{,u\\lambda\\lambda\\lambda}(u_0, \\lambda_0)&\\E_{uu\\lambda\\lambda}&=\\E_{,uu\\lambda\\lambda}(u_0, \\lambda_0)\\\\\\E_{uuu\\lambda}&=\\E_{,uuu\\lambda}(u_0, \\lambda_0)&\\E_{4}&=\\E_{,uuuu}(u_0, \\lambda_0)&\\end{align}\\)\n\n\nwhere\n\n\\(\\E_\\lambda\\), \\(\\E_{\\lambda\\lambda}\\), \\(\\E_{\\lambda\\lambda\\lambda}\\) and \\(\\E_{\\lambda\\lambda\\lambda\\lambda}\\) are scalar quantities,\n\\(\\E_{u\\lambda}\\), \\(\\E_{u\\lambda\\lambda}\\) and \\(\\E_{u\\lambda\\lambda\\lambda}\\) are linear forms,\n\\(\\E_2\\), \\(\\E_{uu\\lambda}\\) and \\(\\E_{uu\\lambda\\lambda}\\) are bilinear forms,\n\\(\\E_3\\) and \\(\\E_{uuu\\lambda}\\) are trilinear forms,\n\\(\\E_4\\) is a quadrilinear form.\n\n\n\n\n\n\n\nImportant\n\n\n\nNote that all these differentials are defined as SymPy scalars. A definition as a SymPy function (e.g. E2 = Function(r\"\\E_2\")) would be more appropriate. However, SymPy would fail to account for multilinearity or symmetry of these forms. Therefore, we use the following trick: all multi-linear forms are defined as scalars, and the standard multiplication operator * means function application. In other words, E2 * (α * u + β * v) * w (resp. E2 * u * v - E2 * v * u) should be understood as E2(α * u + β * v, w) (resp. E2(u, v) - E2(v, u)). In both cases, the expressions would are correctly simplified.\nWhether the symbols in an expression are true scalars or vectors (elements of \\(U\\)) should be clear from the context. For example, in the expression: λ * E2 * u * v, the first * is a true multiplication, while the other * refer to function application.\n\n\nThe energy \\(\\E(u, \\lambda)\\) is now expressed as a Taylor expansion about the critical point.\n\n_f = lambda p, q: binomial(p + q, p) / factorial(p + q)\nE = sum(_f(p, q) * dE_pq * u**p * λ**q for (p, q), dE_pq in dE.items())\n\n\n\nCode\nlsk.display_latex_equation(r\"\\E(u, \\lambda)\", E)\n\n\n\\(\\displaystyle \\E(u, \\lambda)=\\frac{\\E_{2} u^{2}}{2} + \\frac{\\E_{3} u^{3}}{6} + \\frac{\\E_{4} u^{4}}{24} + \\frac{\\E_{\\lambda\\lambda\\lambda\\lambda} \\lambda^{4}}{24} + \\frac{\\E_{\\lambda\\lambda\\lambda} \\lambda^{3}}{6} + \\frac{\\E_{\\lambda\\lambda} \\lambda^{2}}{2} + \\E_{\\lambda} \\lambda + \\frac{\\E_{u\\lambda\\lambda\\lambda} \\lambda^{3} u}{6} + \\frac{\\E_{u\\lambda\\lambda} \\lambda^{2} u}{2} + \\E_{u\\lambda} \\lambda u + \\frac{\\E_{uu\\lambda\\lambda} \\lambda^{2} u^{2}}{4} + \\frac{\\E_{uu\\lambda} \\lambda u^{2}}{2} + \\frac{\\E_{uuu\\lambda} \\lambda u^{3}}{6}\\)\n\n\nWe now turn to the definition of the fundamental path \\(\\lambda \\mapsto u^\\star(\\lambda)\\). We first define in a dictionary the derivatives of \\(u^\\star\\) with respect to \\(\\lambda\\), at \\(\\lambda = \\lambda_0 = 0\\). For example, du_0[2] is the symbol \\(\\ddot{u}_0\\), which stands for \\(\\D^2 u^\\star / \\D \\lambda^2 \\rvert_{\\lambda=\\lambda_0}\\).\n\ndu_0 = {n: Symbol(\"\\\\\" + \"\".join(n * (\"d\",)) + \"ot{u}_0\") for n in range(1, 5)}\n\n_dict = {f\"\\\\frac{{\\\\D^{k}u^\\\\ast}}{{\\\\D \\\\lambda^{k}}}\" : v for k, v in du_0.items()}\n\n\n\nCode\nlsk.display_latex_dict(_dict, num_cols=4)\n\n\n\\(\\displaystyle \\begin{align}\\frac{\\D^1u^\\ast}{\\D \\lambda^1}&=\\dot{u}_0&\\frac{\\D^2u^\\ast}{\\D \\lambda^2}&=\\ddot{u}_0&\\frac{\\D^3u^\\ast}{\\D \\lambda^3}&=\\dddot{u}_0&\\frac{\\D^4u^\\ast}{\\D \\lambda^4}&=\\ddddot{u}_0\\\\\\end{align}\\)\n\n\nThe fundamental path is then defined through its Taylor expansion.\n\nu_star = sum(λ**n / factorial(n) * v for n, v in du_0.items())\n\n\n\nCode\nlsk.display_latex_equation(r\"u^\\star(\\lambda)\", u_star)\n\n\n\\(\\displaystyle u^\\star(\\lambda)=\\frac{\\ddddot{u}_0 \\lambda^{4}}{24} + \\frac{\\dddot{u}_0 \\lambda^{3}}{6} + \\frac{\\ddot{u}_0 \\lambda^{2}}{2} + \\dot{u}_0 \\lambda\\)"
  },
  {
    "objectID": "setting-up_the_computational_stage.html#sec-20230208081549",
    "href": "setting-up_the_computational_stage.html#sec-20230208081549",
    "title": "4  Setting-up the computational stage",
    "section": "4.2 Elimination of the mixed derivatives of the energy",
    "text": "4.2 Elimination of the mixed derivatives of the energy\nSince the fundamental path \\(\\lambda \\mapsto u^\\ast(\\lambda)\\) is an equilibrium path, the various differentials of the energy at the critical point are not linearly independent. To express the relationships between these forms, we define \\(\\mathcal R^\\ast(\\lambda; \\bullet)\\) as the jacobian of the energy along the fundamental path \\(u^\\ast(\\lambda)\\) \\[\n\\mathcal R^\\ast(\\lambda; \\bullet) = \\E_{,u}[u^\\ast(\\lambda), \\lambda; \\bullet].\n\\]\n\nR_star = (E.diff(u) * u_hat).subs(u, u_star).expand()\n\n\n\nCode\nlsk.display_latex_equation(r\"\\mathcal{R}^\\ast(\\lambda;\" + sympy.latex(u_hat) + \")\",\n                           R_star.series(λ, 0, 5))\n\n\n\\(\\displaystyle \\mathcal{R}^\\ast(\\lambda;\\hat{u})=\\lambda \\left(\\E_{2} \\dot{u}_0 \\hat{u} + \\E_{u\\lambda} \\hat{u}\\right) + \\lambda^{2} \\left(\\frac{\\E_{2} \\ddot{u}_0 \\hat{u}}{2} + \\frac{\\E_{3} \\dot{u}_0^{2} \\hat{u}}{2} + \\frac{\\E_{u\\lambda\\lambda} \\hat{u}}{2} + \\E_{uu\\lambda} \\dot{u}_0 \\hat{u}\\right) + \\lambda^{3} \\left(\\frac{\\E_{2} \\dddot{u}_0 \\hat{u}}{6} + \\frac{\\E_{3} \\ddot{u}_0 \\dot{u}_0 \\hat{u}}{2} + \\frac{\\E_{4} \\dot{u}_0^{3} \\hat{u}}{6} + \\frac{\\E_{u\\lambda\\lambda\\lambda} \\hat{u}}{6} + \\frac{\\E_{uu\\lambda\\lambda} \\dot{u}_0 \\hat{u}}{2} + \\frac{\\E_{uu\\lambda} \\ddot{u}_0 \\hat{u}}{2} + \\frac{\\E_{uuu\\lambda} \\dot{u}_0^{2} \\hat{u}}{2}\\right) + \\lambda^{4} \\left(\\frac{\\E_{2} \\ddddot{u}_0 \\hat{u}}{24} + \\frac{\\E_{3} \\dddot{u}_0 \\dot{u}_0 \\hat{u}}{6} + \\frac{\\E_{3} \\ddot{u}_0^{2} \\hat{u}}{8} + \\frac{\\E_{4} \\ddot{u}_0 \\dot{u}_0^{2} \\hat{u}}{4} + \\frac{\\E_{uu\\lambda\\lambda} \\ddot{u}_0 \\hat{u}}{4} + \\frac{\\E_{uu\\lambda} \\dddot{u}_0 \\hat{u}}{6} + \\frac{\\E_{uuu\\lambda} \\ddot{u}_0 \\dot{u}_0 \\hat{u}}{2}\\right) + O\\left(\\lambda^{5}\\right)\\)\n\n\nOf course, since \\(\\lambda \\mapsto u^\\ast(\\lambda)\\) is an equilibrium path, we have \\(\\mathcal R^\\ast(\\lambda; \\bullet) = 0\\) for all \\(\\lambda\\). Therefore, all coefficients of the above polynomial in \\(\\lambda\\) are null, which delivers expressions of \\(\\E_{u\\lambda}\\), \\(\\E_{u\\lambda\\lambda}\\) and \\(\\E_{u\\lambda\\lambda\\lambda}\\)\n\nmixed1 = dict()\n\nfor q in range(1, 4):\n    x = dE[1, q]\n    eq = R_star.coeff(λ, q)\n    sol = solve(eq, x)[0]\n    mixed1[x] = sol\n\n\n\nCode\nlsk.display_latex_dict(mixed1, num_cols=1)\n\n\n\\(\\displaystyle \\begin{align}\\E_{u\\lambda}&=- \\E_{2} \\dot{u}_0\\\\\\E_{u\\lambda\\lambda}&=- \\E_{2} \\ddot{u}_0 - \\E_{3} \\dot{u}_0^{2} - 2 \\E_{uu\\lambda} \\dot{u}_0\\\\\\E_{u\\lambda\\lambda\\lambda}&=- \\E_{2} \\dddot{u}_0 - 3 \\E_{3} \\ddot{u}_0 \\dot{u}_0 - \\E_{4} \\dot{u}_0^{3} - 3 \\E_{uu\\lambda\\lambda} \\dot{u}_0 - 3 \\E_{uu\\lambda} \\ddot{u}_0 - 3 \\E_{uuu\\lambda} \\dot{u}_0^{2}\\\\\\end{align}\\)\n\n\nWe want to get rid of the remaining mixed derivatives, namely: \\(\\E_{uu\\lambda}\\), \\(\\E_{uuu\\lambda}\\) and \\(\\E_{uu\\lambda\\lambda}\\). To do so, we introduce the derivatives \\(\\dot{\\E}_2\\), \\(\\ddot{\\E}_2\\) and \\(\\dot{\\E}_3\\) defined in Chapter 2.\n\nE2_dot, E2_ddot, E3_dot = sympy.symbols(\"\\dot{\\E}_2 \\ddot{\\E}_2 \\dot{\\E}_3\")\n\nE_uu_star = E.diff(u, 2).subs(u, u_star).expand()\nE_uuu_star = E.diff(u, 3).subs(u, u_star).expand()\n\neqs = [Eq(E2_dot, E_uu_star.coeff(λ, 1)),\n       Eq(E3_dot, E_uuu_star.coeff(λ, 1)),\n       Eq(E2_ddot, 2 * E_uu_star.coeff(λ, 2))]\n\nunknowns = [dE[2, 1], dE[3, 1], dE[2, 2]] # E_uuλ, E_uuuλ, E_uuλλ\n\nmixed2 = dict()\nfor eq, x in zip(eqs, unknowns):\n    mixed2[x] = solve(eq, x)[0].subs(mixed2).expand()\n\nWe get the following expressions\n\n\nCode\nlsk.display_latex_dict(mixed2, num_cols=1)\n\n\n\\(\\displaystyle \\begin{align}\\E_{uu\\lambda}&=- \\E_{3} \\dot{u}_0 + \\dot{\\E}_2\\\\\\E_{uuu\\lambda}&=- \\E_{4} \\dot{u}_0 + \\dot{\\E}_3\\\\\\E_{uu\\lambda\\lambda}&=- \\E_{3} \\ddot{u}_0 + \\E_{4} \\dot{u}_0^{2} + \\ddot{\\E}_2 - 2 \\dot{\\E}_3 \\dot{u}_0\\\\\\end{align}\\)\n\n\nCombining the above results allows to fully eliminate the mixed derivatives\n\n\nCode\nmixed = {k: v.subs(mixed2).expand() for k, v in mixed1.items()}\nmixed.update(mixed2)\n\nlsk.display_latex_dict(mixed, num_cols=1)\n\n\n\\(\\displaystyle \\begin{align}\\E_{u\\lambda}&=- \\E_{2} \\dot{u}_0\\\\\\E_{u\\lambda\\lambda}&=- \\E_{2} \\ddot{u}_0 + \\E_{3} \\dot{u}_0^{2} - 2 \\dot{\\E}_2 \\dot{u}_0\\\\\\E_{u\\lambda\\lambda\\lambda}&=- \\E_{2} \\dddot{u}_0 + 3 \\E_{3} \\ddot{u}_0 \\dot{u}_0 - \\E_{4} \\dot{u}_0^{3} - 3 \\ddot{\\E}_2 \\dot{u}_0 - 3 \\ddot{u}_0 \\dot{\\E}_2 + 3 \\dot{\\E}_3 \\dot{u}_0^{2}\\\\\\E_{uu\\lambda}&=- \\E_{3} \\dot{u}_0 + \\dot{\\E}_2\\\\\\E_{uuu\\lambda}&=- \\E_{4} \\dot{u}_0 + \\dot{\\E}_3\\\\\\E_{uu\\lambda\\lambda}&=- \\E_{3} \\ddot{u}_0 + \\E_{4} \\dot{u}_0^{2} + \\ddot{\\E}_2 - 2 \\dot{\\E}_3 \\dot{u}_0\\\\\\end{align}\\)\n\n\nThese expressions can be plugged into the expansion of the energy.\n\nE = E.subs(mixed).expand()\n\n\n\nCode\nlsk.display_latex_equation(r\"\\E(u, \\lambda)\", E)\n\n\n\\(\\displaystyle \\E(u, \\lambda)=- \\frac{\\E_{2} \\dddot{u}_0 \\lambda^{3} u}{6} - \\frac{\\E_{2} \\ddot{u}_0 \\lambda^{2} u}{2} - \\E_{2} \\dot{u}_0 \\lambda u + \\frac{\\E_{2} u^{2}}{2} + \\frac{\\E_{3} \\ddot{u}_0 \\dot{u}_0 \\lambda^{3} u}{2} - \\frac{\\E_{3} \\ddot{u}_0 \\lambda^{2} u^{2}}{4} + \\frac{\\E_{3} \\dot{u}_0^{2} \\lambda^{2} u}{2} - \\frac{\\E_{3} \\dot{u}_0 \\lambda u^{2}}{2} + \\frac{\\E_{3} u^{3}}{6} - \\frac{\\E_{4} \\dot{u}_0^{3} \\lambda^{3} u}{6} + \\frac{\\E_{4} \\dot{u}_0^{2} \\lambda^{2} u^{2}}{4} - \\frac{\\E_{4} \\dot{u}_0 \\lambda u^{3}}{6} + \\frac{\\E_{4} u^{4}}{24} + \\frac{\\E_{\\lambda\\lambda\\lambda\\lambda} \\lambda^{4}}{24} + \\frac{\\E_{\\lambda\\lambda\\lambda} \\lambda^{3}}{6} + \\frac{\\E_{\\lambda\\lambda} \\lambda^{2}}{2} + \\E_{\\lambda} \\lambda - \\frac{\\ddot{\\E}_2 \\dot{u}_0 \\lambda^{3} u}{2} + \\frac{\\ddot{\\E}_2 \\lambda^{2} u^{2}}{4} - \\frac{\\ddot{u}_0 \\dot{\\E}_2 \\lambda^{3} u}{2} - \\dot{\\E}_2 \\dot{u}_0 \\lambda^{2} u + \\frac{\\dot{\\E}_2 \\lambda u^{2}}{2} + \\frac{\\dot{\\E}_3 \\dot{u}_0^{2} \\lambda^{3} u}{2} - \\frac{\\dot{\\E}_3 \\dot{u}_0 \\lambda^{2} u^{2}}{2} + \\frac{\\dot{\\E}_3 \\lambda u^{3}}{6}\\)\n\n\nFrom which we deduce the expression of the residual \\(\\E_{,u}\\) and the hessian of the energy \\(\\E_{,uu}\\).\n\nE_u = E.diff(u)\nE_uu = E.diff(u, 2)\n\n\n\nCode\nlsk.display_latex_equation(r\"\\E_{,u}(u, \\lambda)\", E_u)\nlsk.display_latex_equation(r\"\\E_{,uu}(u, \\lambda)\", E_uu)\n\n\n\\(\\displaystyle \\E_{,u}(u, \\lambda)=- \\frac{\\E_{2} \\dddot{u}_0 \\lambda^{3}}{6} - \\frac{\\E_{2} \\ddot{u}_0 \\lambda^{2}}{2} - \\E_{2} \\dot{u}_0 \\lambda + \\E_{2} u + \\frac{\\E_{3} \\ddot{u}_0 \\dot{u}_0 \\lambda^{3}}{2} - \\frac{\\E_{3} \\ddot{u}_0 \\lambda^{2} u}{2} + \\frac{\\E_{3} \\dot{u}_0^{2} \\lambda^{2}}{2} - \\E_{3} \\dot{u}_0 \\lambda u + \\frac{\\E_{3} u^{2}}{2} - \\frac{\\E_{4} \\dot{u}_0^{3} \\lambda^{3}}{6} + \\frac{\\E_{4} \\dot{u}_0^{2} \\lambda^{2} u}{2} - \\frac{\\E_{4} \\dot{u}_0 \\lambda u^{2}}{2} + \\frac{\\E_{4} u^{3}}{6} - \\frac{\\ddot{\\E}_2 \\dot{u}_0 \\lambda^{3}}{2} + \\frac{\\ddot{\\E}_2 \\lambda^{2} u}{2} - \\frac{\\ddot{u}_0 \\dot{\\E}_2 \\lambda^{3}}{2} - \\dot{\\E}_2 \\dot{u}_0 \\lambda^{2} + \\dot{\\E}_2 \\lambda u + \\frac{\\dot{\\E}_3 \\dot{u}_0^{2} \\lambda^{3}}{2} - \\dot{\\E}_3 \\dot{u}_0 \\lambda^{2} u + \\frac{\\dot{\\E}_3 \\lambda u^{2}}{2}\\)\n\n\n\\(\\displaystyle \\E_{,uu}(u, \\lambda)=\\E_{2} - \\frac{\\E_{3} \\ddot{u}_0 \\lambda^{2}}{2} - \\E_{3} \\dot{u}_0 \\lambda + \\E_{3} u + \\frac{\\E_{4} \\dot{u}_0^{2} \\lambda^{2}}{2} - \\E_{4} \\dot{u}_0 \\lambda u + \\frac{\\E_{4} u^{2}}{2} + \\frac{\\ddot{\\E}_2 \\lambda^{2}}{2} + \\dot{\\E}_2 \\lambda - \\dot{\\E}_3 \\dot{u}_0 \\lambda^{2} + \\dot{\\E}_3 \\lambda u\\)\n\n\nSome of the previous symbolic results are now saved for testing in the next section.\n\nimport json\n\ndata = {\n    \"E\" : srepr(E),\n    \"E_u\" : srepr(E_u),\n    \"E_uu\" : srepr(E_uu),\n    \"u_star\": srepr(u_star),\n    \"E_uλ\": srepr(mixed[dE[1, 1]]),\n    \"E_uλλ\": srepr(mixed[dE[1, 2]]),\n    \"E_uλλλ\": srepr(mixed[dE[1, 3]]),\n    \"E_uuλ\": srepr(mixed[dE[2, 1]]),\n    \"E_uuλλ\": srepr(mixed[dE[2, 2]]),\n    \"E_uuuλ\": srepr(mixed[dE[3, 1]])\n}\n\nwith open(\"setting-up_the_computational_stage.out.json\", \"w\") as f:\n    json.dump(data, f)"
  },
  {
    "objectID": "setting-up_the_computational_stage.html#implementation-in-the-lsk-module-of-the-above-results",
    "href": "setting-up_the_computational_stage.html#implementation-in-the-lsk-module-of-the-above-results",
    "title": "4  Setting-up the computational stage",
    "section": "4.3 Implementation in the lsk module of the above results",
    "text": "4.3 Implementation in the lsk module of the above results\nAll the above results are reimplemented in the lsk module for further use in the subsequent derivations. The whole module is listed below.\nAll the relevant symbols are first defined: E2, E3, E4, E2_dot, E3_dot, E2_ddot, E_λ, E_λλ, E_λλλ, E_λλλλ, u0_dot, u0_ddot, u0_dddot and u0_ddddot.\nWe also define the symbols: λ_, ξ_, v_, w_, E_, E_dot_ and E_ddot_ that are all instances of the class IndexedBase. In other words, they can be indexed with symbolic indices\n\nv_[i] → \\(v_i\\)\nE_[i, j, k] → \\(E_{ijk}\\)\n\netc.\nThen, the mixed derivatives E_uλ, E_uλλ, E_uλλλ, E_uuλ, E_uuλλ and E_uuuλ are defined as expressions of the previous symbols, according to the results derived above.\nIn the derivations to come, we will need to manipulate indexed expression. This is a bit awkward with SymPy (see Indexed objects). In particular, it is recommended to use unique indices as much as possible (see warning at the bottom of the Methods section).\nTo ensure that unique indices are indeed used, we will use functions to create expressions on the fly. It will be assumed that the functions λ_fun() and u_fun() have been defined, that return expressions of \\(\\lambda\\) and \\(u\\) (bifurcated branch) respectively, with unique indices. As we do not have to handle indexed expressions, yet, the most basic implementation of these two functions will suffice for the time being (see default_λ_fun() and default_u_fun).\nThe functions create_E(), create_E_u() and create_E_uu() then return the expressions of the energy and its first and second derivative with respect to \\(u\\), with unique indices. All these functions take u_fun and λ_fun as arguments.\nSimilarly, the function create_u_star() returns the expression of the fundamental branch \\(u^\\star\\). It takes λ_fun as unique argument.\nFinally, we define a set of simplification rules\n\nrules[\"E_ij\"]: \\(\\E_2(v_i, \\bullet) \\rightsquigarrow 0\\),\nrules[r\"\\dot{E}_ij\"]: \\(\\dot{\\E}_2(v_i, v_j) \\rightsquigarrow \\dot{E}_{ij}\\), see Eq. (2.6),\nrules[r\"\\ddot{E}_ij\"]: \\(\\ddot{\\E}_2(v_i, v_j) \\rightsquigarrow \\ddot{E}_{ij} - \\ldots\\), see Eq. (2.7),\nrules[r\"E_ijk\"]: \\(\\E_3(v_i, v_j, v_k) \\rightsquigarrow E_{ijk}\\), see Eq. (2.8),\nrules[r\"\\dot{E}_ijk\"]: \\(\\dot{\\E}_3(v_i, v_j, v_k) \\rightsquigarrow \\dot{E}_{ijk} - \\ldots\\), see Eq. (2.9),\nrules[\"E_ijkl\"]: \\(\\E_4(v_i, v_j, v_k, v_l) \\rightsquigarrow E_{ijkl} - \\ldots\\), see Eq. (2.10),\nrules[\"w_ji = w_ij\"] and rules[\"λ_ji = λ_ij\"], which express that \\(w_{ij}\\) and \\(\\lambda_{ij}\\) (to be defined later) are symmetric with respect to the indices \\(i\\) and \\(j\\).\n\nNote that, from the variational problems (2.4) and (2.5), we have\n\\[\n\\E3(v_i, v_j, w_{k\\lambda}) = -\\E_2(w_{ij}, w_{k\\lambda}) = \\dot{\\E}_2(w_{ij}, v_k),\n\\]\nwhich is implemented as rules[\"E₃(v_i, v_j, w_kλ)\"]. Similarly,\n\\[\n2\\dot{\\E}_2(v_i, w_{j\\lambda})\n= \\dot{\\E}_2(v_i, w_{j\\lambda}) -\\E_2(w_{i\\lambda}, w_{j\\lambda})\n= \\dot{\\E}_2(v_i, w_{j\\lambda}) + \\E_2(v_j, w_{i\\lambda})\n= \\ddot{E}_{ij} - \\ddot{E}_2(v_i, v_j),\n\\]\nwhich is implemented as `rules[“” where \\(\\ddot{E}_{ij}\\) is defined by Eq. (2.7).\n\n%psource lsk\n\n\nimport IPython.display\nimport json\nimport sympy\n\nfrom sympy import Add, expand, Idx, IndexedBase, Integer, Mul, Pow, Rational, Symbol\n\n\ndef __latex(x):\n    return x if str(x) == x else sympy.latex(x)\n\n\ndef display_latex_str(s):\n    display(IPython.display.Math(s))\n\n\ndef display_latex_dict(d, num_cols=2):\n    s = \"\\\\begin{align}\"\n    col = 1\n    for k, v in d.items():\n        s += __latex(k) + \"&=\" + __latex(v)\n        s += r\"\\\\\" if col % num_cols == 0 else r\"&\"\n        col += 1\n    s += \"\\\\end{align}\"\n    display_latex_str(s)\n\n\ndef display_latex_equation(lhs, rhs):\n    display_latex_str(__latex(lhs) + \"=\" + __latex(rhs))\n\nE2 = Symbol(r\"\\E_2\")\nE3 = Symbol(r\"\\E_3\")\nE4 = Symbol(r\"\\E_4\")\nE2_dot = Symbol(r\"\\dot{\\E}_2\")\nE3_dot = Symbol(r\"\\dot{\\E}_3\")\nE2_ddot = Symbol(r\"\\ddot{\\E}_2\")\nE_λ = Symbol(r\"\\E_{\\lambda}\")\nE_λλ = Symbol(r\"\\E_{\\lambda\\lambda}\")\nE_λλλ = Symbol(r\"\\E_{\\lambda\\lambda\\lambda}\")\nE_λλλλ = Symbol(r\"\\E_{\\lambda\\lambda\\lambda\\lambda}\")\nu0_dot = Symbol(r\"\\dot{u}_0\")\nu0_ddot = Symbol(r\"\\ddot{u}_0\")\nu0_dddot = Symbol(r\"\\dddot{u}_0\")\nu0_ddddot = Symbol(r\"\\ddddot{u}_0\")\n\n# Standard indices, to be used in finalized expressions\ni = Idx(\"i\")\nj = Idx(\"j\")\nk = Idx(\"k\")\nl = Idx(\"l\")\n\n# Instances of the `IndexedBase` class end with `_`\n\nλ_ = IndexedBase(r\"\\lambda\")\nξ_ = IndexedBase(r\"\\xi\")\nξ1_ = IndexedBase(r\"{\\order[1]{\\xi}}\")\nξ2_ = IndexedBase(r\"{\\order[2]{\\xi}}\")\nv_ = IndexedBase(\"v\")\nw_ = IndexedBase(\"w\")\nE_ = IndexedBase(\"E\")\nE_dot_ = IndexedBase(\"\\dot{E}\")\nE_ddot_ = IndexedBase(\"\\ddot{E}\")\n\nλ1 = Symbol(r\"{\\order[1]{\\lambda}}\")\nλ2 = Symbol(r\"{\\order[2]{\\lambda}}\")\n\nrules = dict()\n_λ = Idx(r\"\\lambda\")\n\nrules[\"E_ij\"] = {\n    E2 * v_[i]: 0,\n    E2 * v_[j]: 0,\n    E2 * v_[k]: 0,\n    E2 * v_[l]: 0,\n}\n\nrules[r\"\\dot{E}_ij\"] = {\n    E2_dot * v_[i] * v_[j]: E_dot_[i, j],\n    E2_dot * v_[i] * v_[k]: E_dot_[i, k],\n    E2_dot * v_[i] * v_[l]: E_dot_[i, l],\n    E2_dot * v_[j] * v_[k]: E_dot_[j, k],\n    E2_dot * v_[j] * v_[l]: E_dot_[j, l],\n    E2_dot * v_[k] * v_[l]: E_dot_[k, l],\n}\n\nrules[r\"\\ddot{E}_ij\"] = {\n    E2_ddot * v_[i] * v_[j]: (E_ddot_[i, j]\n                              - E2_dot * v_[i] * w_[j, _λ]\n                              - E2_dot * v_[j] * w_[i, _λ]),\n    E2_ddot * v_[i] * v_[k]: (E_ddot_[i, k]\n                              - E2_dot * v_[i] * w_[k, _λ]\n                              - E2_dot * v_[k] * w_[i, _λ]),\n    E2_ddot * v_[i] * v_[l]: (E_ddot_[i, l]\n                              - E2_dot * v_[i] * w_[l, _λ]\n                              - E2_dot * v_[l] * w_[i, _λ]),\n}\n\nrules[r\"E_ijk\"] = {\n    E3 * v_[i] * v_[j] * v_[k]: E_[i, j, k],\n    E3 * v_[i] * v_[j] * v_[l]: E_[i, j, l],\n    E3 * v_[i] * v_[k] * v_[l]: E_[i, k, l],\n}\n\nrules[r\"\\dot{E}_ijk\"] = {\n    E3_dot * v_[i] * v_[j] * v_[k]: (E_dot_[i, j, k] - E2_dot * v_[i] * w_[j, k]\n                                     - E2_dot * v_[j] * w_[i, k] - E2_dot * v_[k] * w_[i, j]),\n    E3_dot * v_[i] * v_[j] * v_[l]: (E_dot_[i, j, l] - E2_dot * v_[i] * w_[j, l]\n                                     - E2_dot * v_[j] * w_[i, l] - E2_dot * v_[l] * w_[i, j]),\n    E3_dot * v_[i] * v_[k] * v_[l]: (E_dot_[i, k, l] - E2_dot * v_[i] * w_[k, l]\n                                     - E2_dot * v_[k] * w_[i, l] - E2_dot * v_[l] * w_[i, k]),\n}\n\nrules[\"E_ijkl\"] = {\n    E4 * v_[i] * v_[j] * v_[k] * v_[l]: (E_[i, j, k, l]\n                                         - E3 * v_[i] * v_[j] * w_[k, l]\n                                         - E3 * v_[i] * v_[k] * w_[j, l]\n                                         - E3 * v_[i] * v_[l] * w_[j, k])\n}\n\nrules[\"w_ij = w_ji\"] = {\n    w_[j, i]: w_[i, j],\n    w_[k, i]: w_[i, k],\n    w_[k, j]: w_[j, k],\n    w_[l, i]: w_[i, l],\n    w_[l, j]: w_[j, l],\n    w_[l, k]: w_[k, l]\n}\n\nrules[\"λ_ij = λ_ji\"] = {\n    λ_[j, i]: λ_[i, j],\n    λ_[k, i]: λ_[i, k],\n    λ_[k, j]: λ_[j, k],\n    λ_[l, i]: λ_[i, l],\n    λ_[l, j]: λ_[j, l],\n    λ_[l, k]: λ_[k, l]\n}\n\nrules[\"E₃(v_i, v_j, w_kλ)\"] = {\n    E3 * v_[i] * v_[j] * w_[k, _λ]: E2_dot * w_[i, j] * v_[k],\n    E3 * v_[i] * v_[k] * w_[j, _λ]: E2_dot * w_[i, k] * v_[j],\n    E3 * v_[i] * v_[k] * w_[l, _λ]: E2_dot * w_[i, k] * v_[l],\n    E3 * v_[i] * v_[l] * w_[k, _λ]: E2_dot * w_[i, l] * v_[k],\n    E3 * v_[i] * v_[j] * w_[l, _λ]: E2_dot * w_[i, j] * v_[l],\n    E3 * v_[i] * v_[l] * w_[j, _λ]: E2_dot * w_[i, l] * v_[j],\n}\n\nrules[r\"\\dot{E}₂(v_i, w_jλ)\"] = {\n    E2_dot * v_[i] * w_[j, _λ]: (E_ddot_[i, j] - E2_ddot * v_[i] * v_[j]) / 2,\n    E2_dot * v_[i] * w_[k, _λ]: (E_ddot_[i, k] - E2_ddot * v_[i] * v_[k]) / 2,\n    E2_dot * v_[i] * w_[l, _λ]: (E_ddot_[i, l] - E2_ddot * v_[i] * v_[l]) / 2,\n}\n\nE_uλ = -E2 * u0_dot\nE_uλλ = -E2 * u0_ddot - 2 * E2_dot * u0_dot + E3 * u0_dot**2\nE_uλλλ = (-E2 * u0_dddot - 3 * E2_dot * u0_ddot - 3 * E2_ddot * u0_dot\n          + 3 * E3 * u0_dot * u0_ddot + 3 * E3_dot * u0_dot**2\n          - E4 * u0_dot**3)\nE_uuλ = E2_dot - E3 * u0_dot\nE_uuλλ = E4 * u0_dot**2 -2 * E3_dot * u0_dot - E3 * u0_ddot + E2_ddot\nE_uuuλ = E3_dot - E4 * u0_dot\n\ndef default_u_fun():\n    return Symbol(r\"u\")\n\n\ndef default_λ_fun():\n    return Symbol(r\"\\lambda\")\n\n\ndef create_E(u_fun=default_u_fun, λ_fun=default_λ_fun):\n    return (λ_fun() * E_λ\n            + (E2 * u_fun() * u_fun()\n               + 2 * λ_fun() * E_uλ * u_fun()\n               + λ_fun() * λ_fun() * E_λλ) / 2\n            + (E3 * u_fun() * u_fun() * u_fun()\n               + 3 * λ_fun() * E_uuλ * u_fun() * u_fun()\n               + 3 * λ_fun() * λ_fun() * E_uλλ * u_fun()\n               + λ_fun() * λ_fun() * λ_fun() * E_λλλ) / 6\n            + (E4 * u_fun() * u_fun() * u_fun() * u_fun()\n               + 4 * λ_fun() * E_uuuλ * u_fun() * u_fun() * u_fun()\n               + 6 * λ_fun() * λ_fun() * E_uuλλ * u_fun() * u_fun()\n               + 4 * λ_fun() * λ_fun() * λ_fun() * E_uλλλ * u_fun()\n               + λ_fun() * λ_fun() * λ_fun() * λ_fun() * E_λλλλ) / 24)\n\n\ndef create_E_u(u_fun=default_u_fun, λ_fun=default_λ_fun):\n    return (E2 * u_fun()\n            + λ_fun() * E_uλ\n            + (E3 * u_fun() * u_fun()\n               + 2 * λ_fun() * E_uuλ * u_fun()\n               + λ_fun() * λ_fun() * E_uλλ) / 2\n            + (E4 * u_fun() * u_fun() * u_fun()\n               + 3 * λ_fun() * E_uuuλ * u_fun() * u_fun()\n               + 3 * λ_fun() * λ_fun() * E_uuλλ * u_fun()\n               + λ_fun() * λ_fun() * λ_fun() * E_uλλλ) / 6)\n\n\ndef create_E_uu(u_fun=default_u_fun, λ_fun=default_λ_fun):\n    return (E2\n            + E3 * u_fun()\n            + λ_fun() * E_uuλ\n            + (E4 * u_fun() * u_fun()\n               + 2 * λ_fun() * E_uuuλ * u_fun()\n               + λ_fun() * λ_fun() * E_uuλλ) / 2)\n\n\ndef create_u_star(λ_fun=default_λ_fun):\n    return (λ_fun() * u0_dot\n            + λ_fun() * λ_fun() * u0_ddot / 2\n            + λ_fun() * λ_fun() * λ_fun() * u0_dddot / 6\n            + λ_fun() * λ_fun() * λ_fun() * λ_fun() * u0_ddddot / 24)\n\ndef autotest():\n    with open(\"setting-up_the_computational_stage.out.json\", \"r\") as f:\n        data = json.load(f)\n\n    assert E_uλ == eval(data[\"E_uλ\"])\n    assert E_uλλ == eval(data[\"E_uλλ\"])\n    assert E_uλλλ == eval(data[\"E_uλλλ\"])\n    assert E_uuλ == eval(data[\"E_uuλ\"])\n    assert E_uuλλ == eval(data[\"E_uuλλ\"])\n    assert E_uuuλ == eval(data[\"E_uuuλ\"])\n\n    assert expand(create_E() - eval(data[\"E\"])) == 0\n    assert expand(create_E_u() - eval(data[\"E_u\"])) == 0\n    assert expand(create_E_uu() - eval(data[\"E_uu\"])) == 0\n\n    assert expand(create_u_star() - eval(data[\"u_star\"])) == 0\n\n\n\n\nThese symbols and functions can then be tested against the expressions derived above (see the asserts at the end of the module).\n\nlsk.autotest()"
  },
  {
    "objectID": "bifurcation_equations.html#outline-of-the-strategy",
    "href": "bifurcation_equations.html#outline-of-the-strategy",
    "title": "5  Bifurcation equations",
    "section": "5.1 Outline of the strategy",
    "text": "5.1 Outline of the strategy\nIn this section, we show that, besides the fundamental branch \\(u^\\ast(\\lambda)\\), other (bifurcated) equilibrium branches may pass through the critical point \\((u_0, \\lambda_0)\\). The starting point is the characterization of an equilibrium by the stationarity of the energy, which defines all equilibrium branches as implicit functions, which can be expanded with respect to some perturbation parameter.\nThe approach adopted here relies on the Lyapunov–Schmidt decomposition (see below). Note that other approaches are possible, see e.g. Chakrabarti et al. (2018).\nFor a given value of \\(\\lambda\\) (close to the critical value \\(\\lambda_0\\)), we seek an equilibrium point \\(u\\) of the system, such that\n\\[\n\\E_{,u}(u, \\lambda; \\hat{u}) = 0 \\quad \\text{for all} \\quad \\hat{u} \\in U.\n\\tag{5.1}\\]\n\nres = (create_E_u() * u_hat).expand()\n\n\n\nCode\ndisplay_latex_equation(res, 0)\n\n\n\\(\\displaystyle - \\frac{\\E_{2} \\dddot{u}_0 \\hat{u} \\lambda^{3}}{6} - \\frac{\\E_{2} \\ddot{u}_0 \\hat{u} \\lambda^{2}}{2} - \\E_{2} \\dot{u}_0 \\hat{u} \\lambda + \\E_{2} \\hat{u} u + \\frac{\\E_{3} \\ddot{u}_0 \\dot{u}_0 \\hat{u} \\lambda^{3}}{2} - \\frac{\\E_{3} \\ddot{u}_0 \\hat{u} \\lambda^{2} u}{2} + \\frac{\\E_{3} \\dot{u}_0^{2} \\hat{u} \\lambda^{2}}{2} - \\E_{3} \\dot{u}_0 \\hat{u} \\lambda u + \\frac{\\E_{3} \\hat{u} u^{2}}{2} - \\frac{\\E_{4} \\dot{u}_0^{3} \\hat{u} \\lambda^{3}}{6} + \\frac{\\E_{4} \\dot{u}_0^{2} \\hat{u} \\lambda^{2} u}{2} - \\frac{\\E_{4} \\dot{u}_0 \\hat{u} \\lambda u^{2}}{2} + \\frac{\\E_{4} \\hat{u} u^{3}}{6} - \\frac{\\ddot{\\E}_2 \\dot{u}_0 \\hat{u} \\lambda^{3}}{2} + \\frac{\\ddot{\\E}_2 \\hat{u} \\lambda^{2} u}{2} - \\frac{\\ddot{u}_0 \\dot{\\E}_2 \\hat{u} \\lambda^{3}}{2} - \\dot{\\E}_2 \\dot{u}_0 \\hat{u} \\lambda^{2} + \\dot{\\E}_2 \\hat{u} \\lambda u + \\frac{\\dot{\\E}_3 \\dot{u}_0^{2} \\hat{u} \\lambda^{3}}{2} - \\dot{\\E}_3 \\dot{u}_0 \\hat{u} \\lambda^{2} u + \\frac{\\dot{\\E}_3 \\hat{u} \\lambda u^{2}}{2}=0\\)\n\n\nfor all \\(\\hat{u} \\in U\\).\nThe equilibrium state \\(u\\) is projected onto the orthogonal subspaces \\(V\\) and \\(W\\). \\[\nu = u^\\ast(\\lambda) + \\xi_i \\, v_i + w, \\quad \\text{with} \\quad w \\in W.\n\\tag{5.2}\\]\nIt follows from the orthogonality of \\(V\\) and \\(W\\) that \\(\\langle v_i, w \\rangle = 0\\) for all \\(i=1, \\ldots, m\\). Analysis of the bifurcated branches therefore reduces to finding \\(\\xi_1, \\ldots, \\xi_m \\in \\reals\\) and \\(w \\in W\\), such that \\[\n\\E_{,u}[u^\\ast(\\lambda) + \\xi_i \\, v_i + w, \\lambda; \\hat{u}] = 0 \\quad \\text{for all} \\quad \\hat{u} \\in U.\n\\tag{5.3}\\]\nThe method proceeds in three steps\n\nEq. (5.3) is first expressed for \\(\\hat{u} \\in W\\) which leads to a definition of \\(w\\) as an implicit function of \\(\\xi_1, \\ldots, \\xi_m\\) and \\(\\lambda\\) (see Section 5.2),\nEq. (5.3) is then expressed for \\(\\hat{u} \\in V\\) which leads to a definition of \\(\\lambda\\) as an implicit function of \\(\\xi_1, \\ldots, \\xi_m\\) (see Section 5.3),\nfinally, a parametrization \\(\\eta\\) of \\(\\xi_1, \\ldots, \\xi_m\\) is introduced and the Taylor expansion of \\(u\\) and \\(\\lambda\\) with respect to \\(\\eta\\) is derived (see Section 5.4)."
  },
  {
    "objectID": "bifurcation_equations.html#sec-20230102030010",
    "href": "bifurcation_equations.html#sec-20230102030010",
    "title": "5  Bifurcation equations",
    "section": "5.2 Elimination of \\(w\\)",
    "text": "5.2 Elimination of \\(w\\)\nWe first test Eq. (5.1) with \\(\\hat{w} \\in W\\) \\[\n\\E_{,u}[u^\\ast(\\lambda) + \\xi_i \\, v_i + w, \\lambda; \\hat{w}] = 0, \\quad \\text{for all} \\quad \\hat{w} \\in W.\n\\tag{5.4}\\]\nThis defines \\(w\\) as an implicit function of \\(\\xi_1, \\ldots, \\xi_m\\) and \\(\\lambda\\). The following asymptotic expansion about \\(\\xi_1 = \\cdots = \\xi_m = 0\\) and \\(\\lambda = \\lambda_0\\) is postulated \\[\n\\begin{aligned}\nw(\\xi_1, \\ldots, \\xi_m, \\lambda) ={} & \\xi_i \\, w_i + \\bigl( \\lambda - \\lambda_0 \\bigr) \\, w_\\lambda + \\tfrac{1}{2} \\xi_i \\, \\xi_j \\, w_{ij}\\\\\n&+ \\tfrac{1}{2} \\bigl( \\lambda - \\lambda_0 \\bigr)^2 w_{\\lambda\\lambda} + \\xi_i \\, \\bigl( \\lambda - \\lambda_0 \\bigr) w_{i\\lambda} + \\cdots,\n\\end{aligned}\n\\tag{5.5}\\] where \\(w_i\\), \\(w_\\lambda\\), \\(w_{ij}\\), \\(w_{\\lambda\\lambda}\\) and \\(w_{i\\lambda}\\) are elements of \\(W\\) to be defined.\nIn what follows, Eq. (5.5) is plugged into Eq. (5.4), which then delivers an asymptotic expansion of the stationarity equation. We will nullify the terms of order up to 2 in \\(\\xi_i\\) and \\(\\lambda\\).\nWe first define the following functions, that ensure that all our expressions use unique indices.\n\n__index_number = itertools.count()\n\ndef new_index():\n    return Idx(r\"i_{\" + str(next(__index_number)) + \"}\")\n\ndef create_λ():\n    return Symbol(r\"\\lambda\")\n\ndef create_w():\n    i = new_index()\n    j = new_index()\n    k = new_index()\n    l = new_index()\n    _λ = Idx(\"\\lambda\")\n    return (t * ξ_[i] * w_[i] + create_λ() * w_[_λ] \n            + (t**2 * ξ_[j] * ξ_[k] * w_[j, k]\n               + 2 * create_λ() * t * ξ_[l] * w_[l, _λ]\n               + create_λ() * create_λ() * w_[_λ, _λ]) / 2)\n    \ndef create_u():\n    i = new_index()\n    return (create_u_star(create_λ) + t * ξ_[i] * v_[i] + create_w())\n\n\nres_w = expand(create_E_u(u_fun=create_u) * w_hat)\n\nWe can then nullify the various coefficients of this polynomial expansion, starting with the terms of order 1 in \\(\\xi_i\\), which delivers the following variational problem\n\nλ = create_λ()\nEq(res_w.coeff(t, 1).subs(λ, 0), 0)\n\n\\(\\displaystyle \\E_{2} \\hat{w} {\\xi}_{i_{0}} {v}_{i_{0}} + \\E_{2} \\hat{w} {\\xi}_{i_{1}} {w}_{i_{1}} = 0\\)\n\n\nfor all \\(\\hat{w} \\in W\\). Since \\(v_i \\in V\\), we have: \\(\\E_2(v_i, \\bullet) = 0\\) and the above variational problem reduces to\n\\[\n\\E_2(w_i, \\hat{w}) = 0 \\quad \\text{for all} \\quad \\hat{w} \\in W.\n\\]\nAs argued in Section 2.2, this leads to \\(w_i = 0\\).\nSimilarly, we find the term or of order 1 in \\(\\lambda\\), and evaluate it at \\(\\xi_1 = \\cdots = \\xi_m = 0\\). Unfortunately, substitutions do not work with indexed quantities. Since all occurences of \\(\\xi_i\\) have been scaled by \\(t\\) so as to keep track of the order of each term, a workaround is to set \\(t\\) to 0. This delivers the following variational problem\n\nres_w.coeff(λ, 1).subs(t, 0)\n\n\\(\\displaystyle \\E_{2} \\hat{w} {w}_{\\lambda}\\)\n\n\nfor all \\(\\hat{w} \\in W\\). The same argument leads to \\(w_\\lambda = 0\\). Similarly again, for the term of order 2 in \\(\\lambda\\) (remembering that \\(w_\\lambda = 0\\))\n\n(eq := Eq(res_w.coeff(λ, 2).subs({\n    t: 0,\n    w_[Idx(r\"\\lambda\")]: 0\n}), 0))\n\n\\(\\displaystyle \\frac{\\E_{2} \\hat{w} {w}_{\\lambda,\\lambda}}{2} = 0\\)\n\n\nfor all \\(\\hat{w} \\in W\\). Therefore, \\(w_{\\lambda\\lambda} = 0\\).\nTo sum up, we have found so far that \\(w_i = w_\\lambda = w_{\\lambda\\lambda} = 0\\). At this point, it is interesting to override the function create_w(), to take into account all these simplifications.\n\ndef create_w():\n    j = new_index()\n    k = new_index()\n    l = new_index()\n    _λ = Idx(r\"\\lambda\")\n    return t**2 * ξ_[j] * ξ_[k] * w_[j, k] / 2 + create_λ() * t * ξ_[l] * w_[l, _λ]\n\nWe can then re-evaluate the residual\n\nres_w = expand(create_E_u(u_fun=create_u) * w_hat)\n\nThe \\(\\xi_i \\, \\xi_j\\) terms deliver the following variational problem\n\nlhs = res_w.coeff(t, 2).subs(λ, 0).expand()\n\n\n\nCode\ndisplay_latex_equation(lhs, 0)\n\n\n\\(\\displaystyle \\frac{\\E_{2} \\hat{w} {\\xi}_{i_{51}} {\\xi}_{i_{52}} {w}_{i_{51},i_{52}}}{2} + \\frac{\\E_{3} \\hat{w} {\\xi}_{i_{54}} {\\xi}_{i_{58}} {v}_{i_{54}} {v}_{i_{58}}}{2}=0\\)\n\n\nfor all \\(\\hat{w} \\in W\\) and \\(\\xi_1, \\ldots, \\xi_m \\in \\reals\\) (small enough). This variational problem should be understood as\n\\[\n\\xi_i \\, \\xi_j \\, \\bigl[ \\E_2(w_{ij}, \\hat{w}) + \\E_3(v_i, v_j, \\hat{w}) \\bigr] = 0\n\\quad \\text{for all} \\quad \\hat{w} \\in W.\n\\]\nfor all \\(\\hat{w} \\in W\\) and \\(\\xi_1, \\ldots, \\xi_m\\) small enough. Since the above expression is homogeneous in \\(\\xi_i\\), it must in fact vanish for all \\(\\xi_1, \\ldots, \\xi_m\\). The resulting variational problem then coincides with (2.4). The \\(\\xi_i \\, \\xi_j\\) term of the asymptotic expansion of \\(w\\) is therefore exactly \\(w_{ij}\\) defined in Chapter 2. Finally, the \\(\\xi_i \\, \\lambda\\) terms deliver the following variational problem\n\nlhs = res_w.coeff(t, 1).coeff(λ, 1).subs(λ, 0).expand()\n\n\n\nCode\ndisplay_latex_equation(lhs, 0)\n\n\n\\(\\displaystyle \\E_{2} \\hat{w} {\\xi}_{i_{53}} {w}_{i_{53},\\lambda} + \\frac{\\E_{3} \\dot{u}_0 \\hat{w} {\\xi}_{i_{54}} {v}_{i_{54}}}{2} + \\frac{\\E_{3} \\dot{u}_0 \\hat{w} {\\xi}_{i_{58}} {v}_{i_{58}}}{2} - \\E_{3} \\dot{u}_0 \\hat{w} {\\xi}_{i_{62}} {v}_{i_{62}} + \\dot{\\E}_2 \\hat{w} {\\xi}_{i_{62}} {v}_{i_{62}}=0\\)\n\n\nfor all \\(\\hat{w} \\in W\\) and \\(\\xi_1, \\ldots, \\xi_m \\in \\reals\\) (small enough). In the above expression, each term contains only one summation index, which is renamed \\(i\\).\n\nterms = lhs.args\nlhs = 0\n\nfor term in terms:\n    d = get_contraction_structure(term)\n    (i_,), = d.keys()\n    lhs += term.subs(i_, i)\n\nThis transformation delivers the following variational problem.\n\n\nCode\ndisplay_latex_equation(lhs, 0)\n\n\n\\(\\displaystyle \\E_{2} \\hat{w} {\\xi}_{i} {w}_{i,\\lambda} + \\dot{\\E}_2 \\hat{w} {\\xi}_{i} {v}_{i}=0\\)\n\n\nfor all \\(\\hat{w} \\in W\\) and \\(\\xi_1, \\ldots, \\xi_m \\in \\reals\\). We recognize the variational problem (2.5). In other words, the \\(\\xi_i \\, \\lambda\\) term of the asymptotic expansion of \\(w\\) is \\(w_{i\\lambda}\\) defined in Chapter 2.\nSo far, we have found the following expansion of \\(w\\)\n\\[\nw(\\xi_1, \\ldots, \\xi_m, \\lambda) = \\tfrac{1}{2} \\xi_i \\, \\xi_j \\, w_{ij} + \\xi_i \\, \\bigl( \\lambda - \\lambda_0 \\bigr) w_{i\\lambda} + \\cdots,\n\\]\nwhere \\(w_{ij}\\) and \\(w_{i\\lambda}\\) are defined by Eqs. (2.4) and (2.5), respectively."
  },
  {
    "objectID": "bifurcation_equations.html#sec-20230102030125",
    "href": "bifurcation_equations.html#sec-20230102030125",
    "title": "5  Bifurcation equations",
    "section": "5.3 Elimination of \\(\\lambda\\)",
    "text": "5.3 Elimination of \\(\\lambda\\)\nWe now test Eq. (5.1) with \\(\\hat{u} = v_i\\) (\\(i = 1, \\ldots, m\\))\n\\[\n\\E_{,u}[u^\\ast(\\lambda) + \\xi_j \\, v_j + w(\\xi_1, \\ldots, \\xi_m, \\lambda), \\lambda; v_i] = 0, \\quad \\text{for all} \\quad i = 1, \\ldots, m.\n\\tag{5.6}\\]\nThis now defines \\(\\lambda\\) as an implicit function of \\(\\xi_1, \\ldots, \\xi_m\\). The following asymptotic expansion about \\(\\xi_1 = \\cdots = \\xi_m = 0\\) is postulated\n\\[\n\\lambda(\\xi_1, \\ldots, \\xi_m) = \\xi_i \\, \\lambda_i + \\tfrac{1}{2} \\, \\xi_i \\, \\xi_j \\, \\lambda_{ij} + \\ldots\n\\tag{5.7}\\]\nwhere \\(\\lambda_i\\) and \\(\\lambda_{ij}\\) are scalar coefficients to be defined below.\nWe first override the function create_λ() that creates (with unique indices) the SymPy expression for the asymptotic expansions of \\((\\xi_1, \\ldots, \\xi_m) \\mapsto \\lambda(\\xi_1, \\ldots, \\xi_m)\\) according to Eq. (5.7). Since the functions create_u() and create_w() call create_λ() internally, there is no need to redefine them to implement the asymptotic expansions of \\((\\xi_1, \\ldots, \\xi_m, \\lambda) \\mapsto w(\\xi_1, \\ldots, \\xi_m, \\lambda)\\) and \\((\\xi_1, \\ldots, \\xi_m) \\mapsto u(\\xi_1, \\ldots, \\xi_m)\\) according to Eqs. (5.5) and (5.2).\n\n\n\n\n\n\nNote\n\n\n\nAlthough \\(\\lambda\\) is expanded to second-order in \\(\\xi_i\\), we will consider third-order terms of the energy below. Therefore, we must make sure that the third-order term of the residual does not involve the third-order term of \\(\\lambda\\). To do so, we define the third-order term of the expansion of \\(\\lambda\\) as a symbol, \\(\\order[3]{\\lambda}\\). We will check later on that this term disappears from the third-order expansion of the energy. We also include the \\(\\mathcal{O}(t^4)\\) term, that will speed up subsequent calculations (by cancelling many terms).\n\n\n\nλ3 = Symbol(r\"\\order[3]{\\lambda}\")\n\ndef create_λ():\n    i = new_index()\n    j = new_index()\n    k = new_index()\n    return t * ξ_[i] * λ_[i] + t**2 / 2 * ξ_[j] * ξ_[k] * λ_[j, k] + t**3 * λ3 + O(t**4)\n\nThen, the above expansions are plugged into the general expression of \\(\\E_{,u}(u, \\lambda; \\bullet)\\) and tested with \\(\\hat{u} = v_i \\in V\\), see Eq. (5.6).\n\nres_v = expand(create_E_u(u_fun=create_u, λ_fun=create_λ) * v_[i]).removeO()\n\nWe get an asymptotic expansion of the residual with respect to \\(\\xi_1, \\ldots, \\xi_m\\). This residual must vanish for all \\(\\xi_i\\) sufficiently small. Therefore, all coefficients of the expansion res_v must be nullified at all orders and for all \\(\\xi_i\\) sufficiently small. Considering the expansion up to third order, we get after simplification only two bifurcation equations, since the terms of order 0 and 1 are identically null, as verified below.\n\nassert res_v.coeff(t, 0) == 0\nassert res_v.coeff(t, 1).subs(rules[\"E_ij\"]) == 0\n\nWe now consider the terms of order 2 in \\(\\xi_i\\) and again standardize the indices: each occurence of \\(\\lambda_a \\, \\xi_a\\) is transformed into \\(\\lambda_j \\, \\xi_j\\), the remaining summation index being renamed \\(k\\). We also introduce the symbols \\(\\dot{E}_{ij}\\) and \\(E_{ijk}\\), defined by Eqs. (2.6) and (2.8), respectively.\n\nlhs1a = res_v.coeff(t, 2).expand().subs(rules[\"E_ij\"])\n\nterms = lhs1a.args\nlhs1b = 0\n\nfor term in terms:\n    indices = next(iter(get_contraction_structure(term).keys()))\n    i1, i2 = indices\n    if degree(term, ξ_[i1]) == 1 and degree(term, λ_[i1]) == 1:\n        term = term.subs({i1: j, i2: k})\n    elif degree(term, ξ_[i2]) == 1 and degree(term, λ_[i2]) == 1:\n        term = term.subs({i2: j, i1: k})\n    else:\n        term = term.subs({i2: j, i1: k})\n    lhs1b += term\n\nlhs1 = lhs1b.subs(rules[r\"\\dot{E}_ij\"]).subs(rules[\"E_ijk\"]).subs(E_dot_[i, k] * λ_[j], E_dot_[i, j] * λ_[k])\n\nAnd get the following equation\n\n\nCode\ndisplay_latex_equation(lhs1, 0)\n\n\n\\(\\displaystyle \\frac{{E}_{i,j,k} {\\xi}_{j} {\\xi}_{k}}{2} + {\\dot{E}}_{i,j} {\\lambda}_{k} {\\xi}_{j} {\\xi}_{k}=0\\)\n\n\nwhich also reads\n\\[\n\\xi_j \\, \\xi_k \\, \\bigl( \\tfrac{1}{2} E_{ijk} + \\lambda_k \\, \\dot{E}_{ij} \\bigr) = 0,\n\\tag{5.8}\\]\nfor all \\(\\xi_1, \\ldots, \\xi_m \\in \\reals\\).\n\n\nCode\nexpected = ξ_[j] * ξ_[k] * (E_[i, j, k] / 2 + λ_[k] * E_dot_[i, j])\nassert expand(lhs1 - expected) == 0\n\n\n\n\n\n\n\n\nNote\n\n\n\nEq. (5.8) results from an asymptotic expansion w.r.t. the \\(\\xi_i\\). As such it needs only be satisfied for all \\(\\xi_1, \\ldots, \\xi_m\\) small enough. However, this equation is homogeneous of degree 2 w.r.t. the \\(\\xi_i\\). Therefore, it indeed holds for all \\(\\xi_1, \\ldots, \\xi_m \\in \\reals\\).\n\n\nTurning now to the term of third-order in \\(\\xi_i\\), the expression with unique indices is hudge. Since each term is multiplied by \\(v_i\\), all occurences of \\(\\E_2\\) are of the form \\(\\E_2(v_i, \\bullet) = 0\\).\n\n_λ = Idx(r\"\\lambda\")\nlhs2a = res_v.coeff(t, 3).subs(E2, 0).expand()\n\nUsing in each term standard index names (\\(j\\), \\(k\\), \\(l\\)) reduces the expression considerably (since many terms that are actually symmetric in these three indices cancel out).\n\ndef standardize_indices(expr):\n    if not expr.is_Mul:\n        raise ValueError()\n    struct = get_contraction_structure(expr)\n    indices = next(iter(struct))\n    if len(indices) == 3:\n        j, k, l = indices\n        return expr.subs({j: Idx(\"j\"), k: Idx(\"k\"), l: Idx(\"l\")})\n    else:\n        raise ValueError()\n\n\nterms = lhs2a.args\nlhs2b = 0\nfor term in terms:\n    lhs2b += standardize_indices(term)\n\nWe now remember that \\(w\\) and \\(\\lambda\\) are symmetric with respect to their two indices.\n\nlhs2c = lhs2b.subs(rules[\"w_ij = w_ji\"]).subs(rules[\"λ_ij = λ_ji\"])\n\nFinally, we perform some minor transformations that are allowed since each term is multiplied by \\(\\xi_j \\, \\xi_k \\, \\xi_l\\).\n\nlhs2 = lhs2b.subs({\n    v_[k] * w_[j, l]: v_[j] * w_[k, l],\n    v_[l] * w_[j, k]: v_[j] * w_[k, l],\n\n    λ_[j] * v_[k] * w_[l, _λ]: λ_[l] * v_[j] * w_[k, _λ],\n    λ_[j] * v_[l] * w_[k, _λ]: λ_[l] * v_[j] * w_[k, _λ],\n    λ_[k] * v_[l] * w_[j, _λ]: λ_[l] * v_[j] * w_[k, _λ],\n\n    λ_[j] * w_[k, l]: λ_[l] * w_[j, k],\n    λ_[k] * w_[j, l]: λ_[l] * w_[j, k],\n\n    λ_[j] * λ_[k] * w_[l, _λ]: λ_[k] * λ_[l] * w_[j, _λ],\n    λ_[j] * λ_[l] * w_[k, _λ]: λ_[k] * λ_[l] * w_[j, _λ],\n    \n    λ_[j, k] * v_[l]: λ_[k, l] * v_[j],\n    λ_[j, l] * v_[k]: λ_[k, l] * v_[j],\n  \n    λ_[j] * v_[k] * v_[l]: λ_[l] * v_[j] * v_[k],\n    λ_[k] * v_[j] * v_[l]: λ_[l] * v_[j] * v_[k],\n    \n    λ_[j] * λ_[k] * v_[l]: λ_[k] * λ_[l] * v_[j],\n    λ_[j] * λ_[l] * v_[k]: λ_[k] * λ_[l] * v_[j],\n\n    λ_[k, l] * w_[j, _λ]: λ_[j, k] * w_[l, _λ],\n    λ_[j, l] * w_[k, _λ]: λ_[j, k] * w_[l, _λ],\n})\n\nAnd we get the second equation (which is homogeneous of degree 3 w.r.t. the \\(\\xi_i\\) and must therefore hold even for large values of these parameters)\n\n\nCode\ndisplay_latex_equation(lhs2, 0)\n\n\n\\(\\displaystyle \\E_{3} {\\lambda}_{l} {\\xi}_{j} {\\xi}_{k} {\\xi}_{l} {v}_{i} {v}_{j} {w}_{k,\\lambda} + \\frac{\\E_{3} {\\xi}_{j} {\\xi}_{k} {\\xi}_{l} {v}_{i} {v}_{j} {w}_{k,l}}{2} + \\frac{\\E_{4} {\\xi}_{j} {\\xi}_{k} {\\xi}_{l} {v}_{i} {v}_{j} {v}_{k} {v}_{l}}{6} + \\frac{\\ddot{\\E}_2 {\\lambda}_{k} {\\lambda}_{l} {\\xi}_{j} {\\xi}_{k} {\\xi}_{l} {v}_{i} {v}_{j}}{2} + \\frac{\\dot{\\E}_2 {\\lambda}_{k,l} {\\xi}_{j} {\\xi}_{k} {\\xi}_{l} {v}_{i} {v}_{j}}{2} + \\dot{\\E}_2 {\\lambda}_{k} {\\lambda}_{l} {\\xi}_{j} {\\xi}_{k} {\\xi}_{l} {v}_{i} {w}_{j,\\lambda} + \\frac{\\dot{\\E}_2 {\\lambda}_{l} {\\xi}_{j} {\\xi}_{k} {\\xi}_{l} {v}_{i} {w}_{j,k}}{2} + \\frac{\\dot{\\E}_3 {\\lambda}_{l} {\\xi}_{j} {\\xi}_{k} {\\xi}_{l} {v}_{i} {v}_{j} {v}_{k}}{2}=0\\)\n\n\nwhich is reordered as follows \\[\n\\begin{aligned}[b]\n\\xi_j \\, \\xi_k \\, \\xi_l \\, \\bigl[\n\\tfrac{1}{2} \\E_3(v_i, v_j, w_{kl})\n+ \\lambda_l \\, \\E_3(v_i, v_j, w_{k\\lambda})\n+ \\tfrac{1}{6} \\E_4(v_i, v_j, v_k, v_l) &\\\\\n+ \\tfrac{1}{2} \\lambda_l \\, \\dot{\\E}_2(v_i, w_{jk})\n+ \\lambda_k \\, \\lambda_l \\, \\dot{\\E}_2(v_i, w_{j\\lambda})\n+ \\tfrac{1}{2} \\lambda_{kl} \\, \\dot{\\E}_2(v_i, v_j) &\\\\\n+ \\tfrac{1}{2} \\lambda_l \\, \\dot{\\E}_3(v_i, v_j, v_k)\n+ \\tfrac{1}{2} \\lambda_k \\, \\lambda_l \\, \\ddot{\\E}_2(v_i, v_j)\n\\bigr] &= 0,\n\\end{aligned}\n\\tag{5.9}\\] for all \\(\\xi_1, \\ldots, \\xi_m \\in \\reals\\).\n\n\nCode\nexpected = ξ_[j] * ξ_[k] * ξ_[l] * (E3 * v_[i] * v_[j] * w_[k, l] / 2\n                                    + λ_[l] * E3 * v_[i] * v_[j] * w_[k, _λ]\n                                    + E4 * v_[i] * v_[j] * v_[k] * v_[l] / 6\n                                    + λ_[l] * E2_dot * v_[i] * w_[j, k] / 2\n                                    + λ_[k] * λ_[l] * E2_dot * v_[i] * w_[j, _λ]\n                                    + λ_[k, l] * E2_dot * v_[i] * v_[j] / 2\n                                    + λ_[l] * E3_dot * v_[i] * v_[j] * v_[k] / 2\n                                    + λ_[k] * λ_[l] * E2_ddot * v_[i] * v_[j] / 2)\n                                    \nassert expand(lhs2 - expected) == 0"
  },
  {
    "objectID": "bifurcation_equations.html#sec-20230616235538",
    "href": "bifurcation_equations.html#sec-20230616235538",
    "title": "5  Bifurcation equations",
    "section": "5.4 Simplification of the bifurcation equations",
    "text": "5.4 Simplification of the bifurcation equations\nIn this section, Eqs. (5.8) and (5.9) are simplified to deliver the bifurcation equations (3.3) and (3.4).\n\n5.4.1 Parametrization of the bifurcated branch\nA parametrization of the bifurcated branch is first introduced. The bifurcated branch is a curve \\((u, \\lambda) \\in \\reals ^ {m + 1}\\), which is parametrized by \\(\\eta\\): \\([u(\\eta), \\lambda(\\eta)]\\), with \\(u(0) = u_0\\) and \\(\\lambda(0) = \\lambda_0\\); primed quantities denoting derivatives with respect to \\(\\eta\\), we introduce\n\\[\n\\order[1]{\\xi_i} = \\xi_i'(0), \\quad \\order[2]{\\xi_i} = \\xi_i''(0), \\quad \\ldots, \\quad \\order[1]{\\lambda} = \\lambda'(0), \\quad \\ldots\n\\]\nIn Section 5.3, \\(\\lambda\\) was defined as a function of \\(\\xi_1, \\ldots, \\xi_m\\). Therefore, from the chain rule\n\\[\n\\lambda'(\\eta) = \\frac{\\partial\\lambda}{\\partial\\xi_i} \\, \\xi_i'(\\eta) \\quad \\text{and} \\quad \\lambda''(\\eta)  = \\frac{\\partial^2\\lambda}{\\partial\\xi_i \\, \\partial\\xi_j} \\, \\xi_i'(\\eta) \\, \\xi_j'(\\eta) + \\frac{\\partial\\lambda}{\\partial\\xi_i} \\, \\xi_i''(\\eta)\n\\]\nand, at \\(\\eta = 0\\)\n\\[\n\\order[1]{\\lambda} = \\lambda_i \\, \\order[1]{\\xi_i} \\quad \\text{and} \\quad \\order[2]{\\lambda} = \\lambda_{ij} \\, \\order[1]{\\xi_i} \\, \\order[1]{\\xi_j} + \\lambda_i \\, \\order[2]{\\xi_i}.\n\\tag{5.10}\\]\nThese two identities are defined as two new simplification rules.\n\nrules[\"λ⁽¹⁾\"] = {\n    λ_[i] * ξ1_[i]: λ1,\n    λ_[j] * ξ1_[j]: λ1,\n    λ_[k] * ξ1_[k]: λ1,\n    λ_[l] * ξ1_[l]: λ1,\n}\n\nrules[\"λ⁽²⁾\"] = {\n    ξ1_[j] * ξ1_[k] * λ_[j, k]: λ2 - λ_[j] * ξ2_[j],\n    ξ1_[j] * ξ1_[l] * λ_[j, l]: λ2 - λ_[j] * ξ2_[j],\n    ξ1_[k] * ξ1_[l] * λ_[k, l]: λ2 - λ_[k] * ξ2_[k]\n}\n\n\n\n5.4.2 Simplification of the first bifurcation equation\nWe first observe that, for fixed \\(i = 1, \\ldots, m\\), Eq. (5.8) is of the form \\(L_{jk} \\, \\xi_j \\, \\xi_k = 0\\) for all \\(\\xi_1, \\ldots, \\xi_m\\). Derivation with respect to \\(\\xi_l\\) leads to\n\\[\n0 = L_{jk} \\, \\delta_{jl} \\, \\xi_k + L_{jk} \\, \\xi_j \\, \\delta_{kl} = L_{lk} \\, \\xi_k + L_{jl} \\, \\xi_j = \\bigl(L_{kl} +L_{lk} \\bigr) \\, \\xi_l,\n\\]\nfor all \\(\\xi_1, \\ldots, \\xi_m \\in \\reals\\). The above identity leads to: \\(L_{kl} + L_{lk} = 0\\). Application to Eq. (5.8) delivers the following identity, to be used below\n\\[\nE_{ijk} + \\lambda_k \\, \\dot{E}_{ij} + \\lambda_j \\, \\dot{E}_{ik} = 0.\n\\tag{5.11}\\]\n\nrules[r\"λ_k ξ²_k \\dot{E}_ij\"] = {\n    λ_[j] * ξ2_[j] * E_dot_[i, k]: -(E_[i, j, k] + λ_[k] * E_dot_[i, j]) * ξ2_[j],\n    λ_[j] * ξ2_[j] * E_dot_[i, l]: -(E_[i, j, l] + λ_[l] * E_dot_[i, j]) * ξ2_[j],\n    λ_[k] * ξ2_[k] * E_dot_[i, j]: -(E_[i, j, k] + λ_[j] * E_dot_[i, k]) * ξ2_[k],\n    λ_[k] * ξ2_[k] * E_dot_[i, l]: -(E_[i, k, l] + λ_[l] * E_dot_[i, k]) * ξ2_[k],\n    λ_[l] * ξ2_[l] * E_dot_[i, j]: -(E_[i, j, l] + λ_[j] * E_dot_[i, l]) * ξ2_[l],\n    λ_[l] * ξ2_[l] * E_dot_[i, k]: -(E_[i, k, l] + λ_[k] * E_dot_[i, l]) * ξ2_[l],\n}\n\nEq. (5.8) holds for all \\(\\xi_1, \\ldots, \\xi_m\\). In particular, it holds for \\(\\xi_i = \\order[1]{\\xi_i}\\) and using Eq. (5.10) delivers\n\nlhs1a = lhs1.subs(ξ_, ξ1_).subs(rules[\"λ⁽¹⁾\"])\n\n\n\nCode\ndisplay_latex_equation(lhs1a, 0)\n\n\n\\(\\displaystyle {\\order[1]{\\lambda}} {\\dot{E}}_{i,j} {{\\order[1]{\\xi}}}_{j} + \\frac{{E}_{i,j,k} {{\\order[1]{\\xi}}}_{j} {{\\order[1]{\\xi}}}_{k}}{2}=0\\)\n\n\nwhich coincides with the first bifurcation equation (3.3).\n\n\nCode\nexpected = E_[i, j, k] * ξ1_[j] * ξ1_[k] / 2 + λ1 * E_dot_[i, j] * ξ1_[j]\n\nassert lhs1a - expected == 0\n\n\n\n\n5.4.3 Simplification of the second bifurcation equation\n\nlhs2a = lhs2.subs(ξ_, ξ1_).expand()\n\nAll terms are of the form \\(L_{ijkl} \\, \\order[1]{\\xi}_j \\, \\order[1]{\\xi}_k \\, \\order[1]{\\xi}_l\\): they can be symmetrized wrt \\(j\\), \\(k\\) and \\(l\\) as follows\n\\[\nL_{ijkl} \\, \\order[1]{\\xi}_j \\, \\order[1]{\\xi}_k \\, \\order[1]{\\xi}_l = \\tfrac{1}{6} \\bigl( L_{ijkl} + L_{ijlk} + L_{ikjl} + L_{iklj} + L_{iljk} + L_{ilkj} \\bigr) \\, \\order[1]{\\xi}_j \\, \\order[1]{\\xi}_k \\, \\order[1]{\\xi}_l\n\\]\n\ndef symmetrize(expr):\n    if not expr.is_Mul:\n        raise ValueError()\n    struct = get_contraction_structure(expr)\n    indices = next(iter(struct))\n    if len(indices) == 3:\n        j, k, l = indices\n        # Assign temporary indices\n        jj = new_index()\n        kk = new_index()\n        ll = new_index()\n        expr = expr.subs({j: jj, k: kk, l: ll})\n        return (expr.subs({jj: j, kk: k, ll: l})\n                + expr.subs({jj: j, kk: l, ll: k})\n                + expr.subs({jj: k, kk: l, ll: j})\n                + expr.subs({jj: k, kk: j, ll: l})\n                + expr.subs({jj: l, kk: j, ll: k})\n                + expr.subs({jj: l, kk: k, ll: j})) / 6\n    else:\n        raise ValueError(expr)\n\nWe perform this symmetrization and use some of the simplification rules already defined.\n\nlhs2b = 0\nfor term in lhs2a.args:\n    lhs2b += symmetrize(term)\n\nnames = [\n    \"λ⁽¹⁾\", \n    \"E_ijkl\", \n    \"E_ijk\", \n    \"\\dot{E}_ijk\", \n    \"E₃(v_i, v_j, w_kλ)\", \n    \"w_ij = w_ji\",\n    \"λ_ij = λ_ji\",\n    r\"\\dot{E}₂(v_i, w_jλ)\",\n    r\"\\ddot{E}_ij\",\n    \"λ⁽²⁾\",\n    r\"\\dot{E}_ij\",\n    \"λ_k ξ²_k \\dot{E}_ij\",\n    \"λ⁽¹⁾\"\n]\n\nfor name in names:\n    lhs2b = lhs2b.subs(rules[name]).expand()\n\nFinally, we apply some minor transformations to the indices.\n\nlhs2c = lhs2b.subs({\n    E_dot_[i, k] * ξ1_[k] : E_dot_[i, j] * ξ1_[j],\n    E_dot_[i, l] * ξ1_[l] : E_dot_[i, j] * ξ1_[j],\n    E_dot_[i, k] * ξ2_[k] : E_dot_[i, j] * ξ2_[j],\n    E_dot_[i, l] * ξ2_[l] : E_dot_[i, j] * ξ2_[j],\n    E_ddot_[i, k] * ξ1_[k] : E_ddot_[i, j] * ξ1_[j],\n    E_ddot_[i, l] * ξ1_[l] : E_ddot_[i, j] * ξ1_[j],\n    E_[i, j, k] * ξ1_[j] * ξ2_[k]: E_[i, j, k] * ξ1_[k] * ξ2_[j],\n    E_[i, j, l] * ξ1_[j] * ξ2_[l]: E_[i, j, k] * ξ1_[k] * ξ2_[j],\n    E_[i, j, l] * ξ1_[l] * ξ2_[j]: E_[i, j, k] * ξ1_[k] * ξ2_[j],\n    E_[i, k, l] * ξ1_[k] * ξ2_[l]: E_[i, j, k] * ξ1_[k] * ξ2_[j],\n    E_[i, k, l] * ξ1_[l] * ξ2_[k]: E_[i, j, k] * ξ1_[k] * ξ2_[j],\n    E_dot_[i, j, l] * ξ1_[j] * ξ1_[l]: E_dot_[i, j, k] * ξ1_[j] * ξ1_[k],\n    E_dot_[i, k, l] * ξ1_[k] * ξ1_[l]: E_dot_[i, j, k] * ξ1_[j] * ξ1_[k],\n}).expand().subs(rules[\"λ⁽¹⁾\"])\n\nand Eq. (3.4) is finally retrieved.\n\n\nCode\nexpected = (E_[i, j, k, l] * ξ1_[j] * ξ1_[k] * ξ1_[l] / 3\n            + λ1 * (E_dot_[i, j, k] * ξ1_[k] + λ1 * E_ddot_[i, j]) * ξ1_[j]\n            + (E_[i, j, k] * ξ1_[k] + λ1 * E_dot_[i, j]) * ξ2_[j]\n            + λ2 * E_dot_[i, j] * ξ1_[j])\n\nassert expand(2 * lhs2c - expected) == 0\n\n\nWe now turn to \\(w\\), which was defined in Section 5.2 as an implicit function of \\(\\xi_1, \\ldots, \\xi_m\\) and \\(\\lambda\\). It is now defined as a function of the arc parameter \\(\\eta\\) as follows: \\(w(n) = w[\\xi_1(\\eta), \\ldots, \\xi_m(\\eta), \\lambda(\\eta)]\\). From the chain rule \\[\nw'(\\eta) = \\frac{\\partial w}{\\partial \\xi_i} \\, \\xi_i' + \\frac{\\partial w}{\\partial \\lambda} \\, \\lambda'\n\\] and \\[\nw''(\\eta) = \\frac{\\partial^2 w}{\\partial \\xi_i \\, \\partial \\xi_j} \\, \\xi_i' \\, \\xi_j'\n+ 2\\frac{\\partial w}{\\partial \\xi_i \\, \\partial \\lambda} \\, \\xi_i' \\, \\lambda'\n+ \\frac{\\partial w}{\\partial \\xi_i} \\, \\xi_i''\n+ \\frac{\\partial^2 w}{\\partial \\lambda^2} \\, \\lambda^{'2}\n+ \\frac{\\partial w}{\\partial \\lambda} \\, \\lambda''.\n\\]\nAt \\(\\eta = 0\\), the above identities reduce to \\[\nw'(0) = 0\n\\quad \\text{and} \\quad\nw''(0) = \\order[1]{\\xi_i} \\, \\order[1]{\\xi_j} \\, w_{ij}  + 2 \\order[1]{\\lambda} \\, \\order[1]{\\xi_i} \\, w_{i\\lambda}\n\\]\nWe deduce from the above the Taylor expansion (3.1) of the bifurcated branch as \\(\\eta \\to 0\\).\n\n\n\n\nChakrabarti, Aditi, Serge Mora, Franck Richard, Ty Phou, Jean-Marc Fromental, Yves Pomeau, and Basile Audoly. 2018. “Selection of Hexagonal Buckling Patterns by the Elastic Rayleigh-Taylor Instability.” Journal of the Mechanics and Physics of Solids 121 (December): 234–57. https://doi.org/10.1016/j.jmps.2018.07.024."
  },
  {
    "objectID": "energy.html#asymptotic-expansion-of-the-hessian-of-the-energy",
    "href": "energy.html#asymptotic-expansion-of-the-hessian-of-the-energy",
    "title": "6  Asymptotic expansion of the energy",
    "section": "6.1 Asymptotic expansion of the hessian of the energy",
    "text": "6.1 Asymptotic expansion of the hessian of the energy\nWe use the same code to derive an asymptotic expansion of the hessian \\(\\E_{,uu}\\) of the energy along the bifurcated branch.\n\nE_uu = (eval(data[\"E_uu\"]).subs({Symbol(\"\\lambda\"): λ, Symbol(\"u\"): u})  + O(η**3)).expand()\n\n\n\nCode\nlsk.display_latex_equation(r\"\\E_{,uu}[u(\\eta), \\lambda(\\eta)]\", E_uu)\n\n\n\\(\\displaystyle \\E_{,uu}[u(\\eta), \\lambda(\\eta)]=\\dot{\\E}_3 \\eta^{2} \\xi_i^{(1)}v_i {\\order[1]{\\lambda}} + \\dot{\\E}_2 \\eta {\\order[1]{\\lambda}} + \\frac{\\dot{\\E}_2 \\eta^{2} {\\order[2]{\\lambda}}}{2} + \\frac{\\ddot{\\E}_2 \\eta^{2} {\\order[1]{\\lambda}}^{2}}{2} + \\frac{\\E_{4} \\eta^{2} \\left(\\xi_i^{(1)}v_i\\right)^{2}}{2} + \\E_{3} \\eta \\xi_i^{(1)}v_i + \\E_{3} \\eta^{2} \\xi_m^{(1)}w_{m\\lambda} {\\order[1]{\\lambda}} + \\frac{\\E_{3} \\eta^{2} \\xi_k^{(1)}\\xi_l^{(1)}w_{kl}}{2} + \\frac{\\E_{3} \\eta^{2} \\xi_j^{(2)}v_j}{2} + \\E_{2} + O\\left(\\eta^{3}\\right)\\)\n\n\nThe above expression must be understood as follows\n\\[\n\\begin{aligned}[b]\n\\E_{,uu}[u(\\eta), \\lambda(\\eta); \\bullet, \\bullet] ={}\n& \\E_2(\\bullet, \\bullet) + \\eta \\, \\bigl[ \\order[1]{\\xi}_i \\, \\E_3(v_i, \\bullet, \\bullet) + \\order[1]{\\lambda} \\, \\dot{\\E}_2(\\bullet, \\bullet) \\bigr]\\\\\n&+ \\tfrac{1}{2}\\eta^2 \\, \\bigl[ \\order[1]{\\xi}_i \\, \\order[1]{\\xi}_j \\, \\E_4(v_i, v_j, \\bullet, \\bullet)\n+ \\order[2]{\\xi}_i \\, \\E_3(v_i, \\bullet, \\bullet) \\\\\n&+ \\order[1]{\\xi}_i \\, \\order[1]{\\xi}_j \\, \\E_3(w_{ij}, \\bullet, \\bullet)\n+ 2\\order[1]{\\lambda} \\, \\order[1]{\\xi}_i \\, \\E_3(w_{i\\lambda}, \\bullet, \\bullet)\\\\\n&+ 2\\order[1]{\\lambda} \\, \\order[1]{\\xi}_i \\, \\dot{\\E}_3(v_i, \\bullet, \\bullet)\n+ (\\order[1]{\\lambda})^2 \\, \\ddot{\\E}_2(\\bullet, \\bullet) + \\order[2]{\\lambda} \\, \\dot{\\E}_2(\\bullet, \\bullet)\\bigr],\n\\end{aligned}\n\\]\nor, equivalently\n\\[\n\\begin{aligned}[b]\n\\E_{,uu}[u(\\eta), \\lambda(\\eta); \\bullet, \\bullet] ={}\n& \\E_2(\\bullet, \\bullet) + \\eta \\, \\bigl[ \\E_3(\\order[1]{u}, \\bullet, \\bullet) + \\order[1]{\\lambda} \\, \\dot{\\E}_2(\\bullet, \\bullet) \\bigr]\\\\\n&+ \\tfrac{1}{2}\\eta^2 \\, \\bigl[ \\E_4(\\order[1]{u}, \\order[1]{u}, \\bullet, \\bullet)\n+ \\E_3(\\order[2]{u}, \\bullet, \\bullet) \\\\\n&+ 2\\order[1]{\\lambda} \\, \\dot{\\E}_3(\\order[1]{u}, \\bullet, \\bullet)\n+ (\\order[1]{\\lambda})^2 \\, \\ddot{\\E}_2(\\bullet, \\bullet) + \\order[2]{\\lambda} \\, \\dot{\\E}_2(\\bullet, \\bullet)\\bigr],\n\\end{aligned}\n\\tag{6.2}\\]\nwhere \\(\\order[1]{u}\\) and \\(\\order[2]{u}\\) are given by Eq. (3.2)."
  },
  {
    "objectID": "eigenmodes.html#variational-problem-of-order-0",
    "href": "eigenmodes.html#variational-problem-of-order-0",
    "title": "7  Eigenmodes of the hessian of the energy",
    "section": "7.1 Variational problem of order 0",
    "text": "7.1 Variational problem of order 0\nThe lowest-order problem reads: find \\(\\order[0]x \\in U\\) and \\(\\order[0]\\alpha\\in\\reals\\) such that, for all \\(\\hat{u} \\in U\\) \\[\n\\E_2(\\order[0]x, \\hat{u}) = \\order[0]\\alpha \\langle \\order[0]x, \\hat{u} \\rangle.\n\\]\nThe above equation shows that \\((\\order[0]\\alpha, \\order[0]x)\\) is an eigenpair of \\(\\E_2\\). Since \\(\\E_2\\) is positive, \\(\\order[0]\\alpha \\geq 0\\). If \\(\\order[0]\\alpha > 0\\), then \\(\\alpha > 0\\) in the neighborhood of \\(\\lambda_0\\), and the eigenmode is stable. Potentially unstable modes are therefore such that \\(\\order[0]\\alpha=0\\). In other words, the lowest-order \\(\\order[0]x\\) belongs to \\(V\\) and can be expressed as a linear combination of the \\(v_i\\)\n\n\nCode\nα0 = 0\nx0 = χ0_j * v_j\n\nlsk.display_latex_dict({\n    r\"\\order[0]{\\alpha}\": α0,\n    r\"\\order[0]x\": x0})\n\n\n\\(\\displaystyle \\begin{align}\\order[0]{\\alpha}&=0&\\order[0]x&={\\order[0]{\\chi_{j}}} {v_{j}}\\\\\\end{align}\\)"
  },
  {
    "objectID": "eigenmodes.html#variational-problem-of-order-1",
    "href": "eigenmodes.html#variational-problem-of-order-1",
    "title": "7  Eigenmodes of the hessian of the energy",
    "section": "7.2 Variational problem of order 1",
    "text": "7.2 Variational problem of order 1\nThe first-order term \\(\\order[1]x\\) is decomposed as the sum of its projections onto \\(V\\) and \\(W\\)\n\n\nCode\nx1 = χ1_j * v_j + y1\nlsk.display_latex_equation(r\"\\order[1]x\", x1)\n\n\n\\(\\displaystyle \\order[1]x={\\order[1]{\\chi_{j}}} {v_{j}} + {\\order[1]{y}}\\)\n\n\nwhere \\(\\order[1]y \\in W\\). We then plug the resulting asymptotic expansions of \\(\\alpha\\) and \\(x\\) into the asymptotic expansions of \\(\\E_{,uu}(x, \\hat{u})\\) and \\(\\alpha \\, \\langle x, \\hat{u} \\rangle\\) and extract the first-order terms.\n\nα = α0 + η * α1\nx = x0 + η * x1\n\nlhs = expand(E_uu * x * u_hat).coeff(η, 1)\nrhs = expand(α * x * u_hat).coeff(η, 1) \n\nThe problem reads: find \\(\\order[1]x \\in U\\) and \\(\\order[1]\\alpha\\in\\reals\\) such that, for all \\(\\hat{u} \\in U\\)\n\n\nCode\nlsk.display_latex_equation(lhs, rhs)\n\n\n\\(\\displaystyle \\E_{2} \\hat{u} {\\order[1]{\\chi_{j}}} {v_{j}} + \\E_{2} \\hat{u} {\\order[1]{y}} + \\E_{3} \\hat{u} {\\order[0]{\\chi_{j}}} {\\order[1]{\\xi_{k}}} {v_{j}} {v_{k}} + \\dot{\\E}_2 \\hat{u} {\\order[0]{\\chi_{j}}} {\\order[1]{\\lambda}} {v_{j}}=\\hat{u} {\\order[0]{\\chi_{j}}} {\\order[1]{\\alpha}} {v_{j}}\\)\n\n\nThe above equation must be understood as \\[\n\\order[1]{\\chi}_i \\, \\E_2(v_i, \\hat{u})\n+ \\E_2(\\order[1]{y}, \\hat{u})\n+ \\order[0]{\\chi}_j \\, \\order[1]{\\xi}_k \\, \\E_3(v_j, v_k, \\hat{u})\n+ \\order[1]{\\lambda} \\, \\order[0]{\\chi}_j \\, \\dot{\\E}_2(v_j, \\hat{u})\n= \\order[1]{\\alpha} \\, \\order[0]{\\chi}_j \\, \\langle v_j, \\hat{u} \\rangle,\n\\] and, since the first term cancels \\[\n\\E_2(\\order[1]{y}, \\hat{u})\n+ \\order[0]{\\chi}_j \\, \\order[1]{\\xi}_k \\, \\E_3(v_j, v_k, \\hat{u})\n+ \\order[1]{\\lambda} \\, \\order[0]{\\chi}_j \\, \\dot{\\E}_2(v_j, \\hat{u})\n= \\order[1]{\\alpha} \\, \\order[0]{\\chi}_j \\, \\langle v_j, \\hat{u} \\rangle,\n\\tag{7.2}\\]\nEq. (7.2) is first tested with \\(\\hat{u} = v_i \\in V\\). Observing that \\(\\langle v_i, v_j \\rangle = \\delta_{ij}\\) since \\((v_i)\\) is orthonormal, we get \\[\n\\bigl[ \\E_3(v_i, v_j, v_k) \\, \\order[1]{\\xi_k} + \\order[1]\\lambda \\, \\dot{\\E}_2(v_i, v_j)\\bigr] \\, \\order[0]{\\chi_j} = \\order[1]\\alpha \\, \\order[0]{\\chi_i},\n\\] which shows that \\((\\order[1]\\alpha, \\order[0]{\\chi_i})\\) is an eigenpair of the symmetric tensor \\((E_{ijk} \\order[1]{\\xi_k} + \\order[1]\\lambda \\, \\dot{E}_{ij})\\) – see Eq. (3.6).\nThe test function is now picked in \\(W = V^\\perp\\) and Eq. (7.2) results in the following variational problem: find \\(\\order[1]y \\in W\\) such that, for all \\(\\hat{w} \\in W\\), \\[\n\\E_2(\\order[1]y, \\hat{w}) + \\E_3(v_i, v_j, \\hat{w}) \\, \\order[0]{\\chi_i} \\, \\order[1]{\\xi_j} + \\order[1]\\lambda \\, \\dot{\\E}_2(v_i, \\hat{w}) \\, \\order[0]{\\chi_i} = 0,\n\\] (observe that \\(\\langle v_j, \\hat{w} \\rangle = 0\\) since \\(V\\) and \\(W\\) are orthogonal subspaces). The solution to the above problem is expressed as a linear combination of the \\(w_{ij}\\) and \\(w_{i\\lambda}\\) –defined by the variational problems (2.4) and (2.5), respectively–, delivering\n\n\nCode\ny1 = χ0_j * ξ1_l * w_jl + λ1 * χ0_j * w_jλ\nx1 = χ1_j * v_j + y1\n\nlsk.display_latex_dict({\n    r\"\\order[1]y\": y1,\n    r\"\\order[1]x\": x1})\n\n\n\\(\\displaystyle \\begin{align}\\order[1]y&={\\order[0]{\\chi_{j}}} {\\order[1]{\\lambda}} {w_{j\\lambda}} + {\\order[0]{\\chi_{j}}} {\\order[1]{\\xi_{l}}} {w_{jl}}&\\order[1]x&={\\order[0]{\\chi_{j}}} {\\order[1]{\\lambda}} {w_{j\\lambda}} + {\\order[0]{\\chi_{j}}} {\\order[1]{\\xi_{l}}} {w_{jl}} + {\\order[1]{\\chi_{j}}} {v_{j}}\\\\\\end{align}\\)"
  },
  {
    "objectID": "eigenmodes.html#variational-problem-of-order-2",
    "href": "eigenmodes.html#variational-problem-of-order-2",
    "title": "7  Eigenmodes of the hessian of the energy",
    "section": "7.3 Variational problem of order 2",
    "text": "7.3 Variational problem of order 2\nThe second-order term \\(\\order[2]x\\) is also decomposed as the sum of its projections onto \\(V\\) and \\(W = V^\\perp\\)\n\n\nCode\nx2 = χ2_j * v_j + y2\n\nlsk.display_latex_equation(r\"\\order[2]x\", x2)\n\n\n\\(\\displaystyle \\order[2]x={\\order[2]{\\chi_{j}}} {v_{j}} + {\\order[2]{y}}\\)\n\n\nwhere \\(\\order[2]y \\in W\\). We then plug the resulting asymptotic expansions of \\(\\alpha\\) and \\(x\\) into the asymptotic expansions of \\(\\E_{,uu}(x, v_i)\\) and \\(\\alpha \\, \\langle x, v_i \\rangle\\) and extract the second-order terms. Note that the test-function \\(v_i\\) belongs to \\(V\\). The resulting variational problem reads: find \\(\\order[1]\\alpha, \\order[1]{\\chi}_1, \\ldots, \\order[1]{\\chi}_m \\in \\reals\\) and \\(\\order[1]y \\in W\\) such that, for all \\(\\hat{v} \\in V\\)\n\n\nCode\nα = α0 + η * α1 + η**2 / 2 * α2\nx = x0 + η * x1 + η**2 / 2 * x2\n\n# The substitution below makes the expression nicer\nlhs_raw = expand(E_uu * x * v_i).coeff(η, 2)\nrhs_raw = expand(α * x * v_i).coeff(η, 2) \n\nlsk.display_latex_equation(lhs_raw, rhs_raw)\n\n\n\\(\\displaystyle \\frac{\\E_{2} {\\order[2]{\\chi_{j}}} {v_{i}} {v_{j}}}{2} + \\frac{\\E_{2} {\\order[2]{y}} {v_{i}}}{2} + \\E_{3} {\\order[0]{\\chi_{j}}} {\\order[1]{\\lambda}} {\\order[1]{\\xi_{k}}} {v_{i}} {v_{j}} {w_{k\\lambda}} + \\E_{3} {\\order[0]{\\chi_{j}}} {\\order[1]{\\lambda}} {\\order[1]{\\xi_{k}}} {v_{i}} {v_{k}} {w_{j\\lambda}} + \\frac{\\E_{3} {\\order[0]{\\chi_{j}}} {\\order[1]{\\xi_{k}}} {\\order[1]{\\xi_{l}}} {v_{i}} {v_{j}} {w_{kl}}}{2} + \\E_{3} {\\order[0]{\\chi_{j}}} {\\order[1]{\\xi_{k}}} {\\order[1]{\\xi_{l}}} {v_{i}} {v_{k}} {w_{jl}} + \\frac{\\E_{3} {\\order[0]{\\chi_{j}}} {\\order[2]{\\xi_{k}}} {v_{i}} {v_{j}} {v_{k}}}{2} + \\E_{3} {\\order[1]{\\chi_{j}}} {\\order[1]{\\xi_{k}}} {v_{i}} {v_{j}} {v_{k}} + \\frac{\\E_{4} {\\order[0]{\\chi_{j}}} {\\order[1]{\\xi_{k}}} {\\order[1]{\\xi_{l}}} {v_{i}} {v_{j}} {v_{k}} {v_{l}}}{2} + \\frac{\\ddot{\\E}_2 {\\order[0]{\\chi_{j}}} {\\order[1]{\\lambda}}^{2} {v_{i}} {v_{j}}}{2} + \\dot{\\E}_2 {\\order[0]{\\chi_{j}}} {\\order[1]{\\lambda}}^{2} {v_{i}} {w_{j\\lambda}} + \\dot{\\E}_2 {\\order[0]{\\chi_{j}}} {\\order[1]{\\lambda}} {\\order[1]{\\xi_{l}}} {v_{i}} {w_{jl}} + \\frac{\\dot{\\E}_2 {\\order[0]{\\chi_{j}}} {\\order[2]{\\lambda}} {v_{i}} {v_{j}}}{2} + \\dot{\\E}_2 {\\order[1]{\\chi_{j}}} {\\order[1]{\\lambda}} {v_{i}} {v_{j}} + \\dot{\\E}_3 {\\order[0]{\\chi_{j}}} {\\order[1]{\\lambda}} {\\order[1]{\\xi_{k}}} {v_{i}} {v_{j}} {v_{k}}={\\order[0]{\\chi_{j}}} {\\order[1]{\\alpha}} {\\order[1]{\\lambda}} {v_{i}} {w_{j\\lambda}} + {\\order[0]{\\chi_{j}}} {\\order[1]{\\alpha}} {\\order[1]{\\xi_{l}}} {v_{i}} {w_{jl}} + \\frac{{\\order[0]{\\chi_{j}}} {\\order[2]{\\alpha}} {v_{i}} {v_{j}}}{2} + {\\order[1]{\\alpha}} {\\order[1]{\\chi_{j}}} {v_{i}} {v_{j}}\\)\n\n\nWe then perform the following substitutions in the left-hand side\n\nCancellation of all terms involving \\(\\E_2\\), since all multilinear forms involved in the left-hand side are evaluated at \\(v_i\\) and \\(\\E_2(v_i, \\bullet) = 0\\).\nRenaming of some indices \\[\\order[1]{\\lambda} \\, \\order[0]{\\chi}_j \\, \\order[1]{\\xi}_l \\, \\dot{\\E}_2(v_i, w_{jl}) \\rightarrow \\order[1]{\\lambda} \\, \\order[0]{\\chi}_j \\, \\order[1]{\\xi}_k \\, \\dot{\\E}_2(v_i, w_{jk})\\]\nSymmetrization of some terms \\[\\order[1]{\\xi}_k \\, \\order[1]{\\xi}_l \\, v_k \\, w_{jl} \\rightarrow \\tfrac{1}{2} \\order[1]{\\xi}_k \\, \\order[1]{\\xi}_l \\, \\bigl(v_k \\, w_{jl} + v_l \\, w_{jk} \\bigr)\\]\nIntroduction of the quantities \\(E_{ij}\\), \\(\\dot{E}_{ij}\\), \\(\\ddot{E}_{ij}\\), \\(E_{ijk}\\), \\(\\dot{E}_{ijk}\\), \\(E_{ijkl}\\) defined in Section 2.4.\nUse of equations (2.4) and (2.5) that define \\(w_{ij}\\) and \\(w_{i\\lambda}\\) \\[\\E_3(v_i, v_j, w_{k\\lambda}) \\rightarrow -\\E_2(w_{ij}, w_{k\\lambda}) \\quad \\text{and} \\quad \\dot{\\E}_2(v_i, w_{j\\lambda}) \\rightarrow -\\E_2(w_{i\\lambda}, w_{j\\lambda})\\]\n\nand in the right-hand side 1. \\((v_i)\\) is orthonormal \\[\\langle v_i, v_j \\rangle \\rightarrow \\delta_{ij}\\] 2. \\(v_i \\in V\\) and \\(w_{j\\lambda}, w_{jl} \\in W = V^\\perp\\) are orthogonal \\[\\langle v_i, w_{j\\lambda} \\rangle \\rightarrow 0 \\quad \\text{and} \\quad \\langle v_i, w_{jl} \\rangle \\rightarrow 0\\]\nThe variational problem of order 2 then reduces to\n\n\nCode\nlhs = (2 * lhs_raw).subs({\n    # Item 1\n    E2: 0,\n    # Item 2\n    λ1 * χ0_j * ξ1_l * E2_dot * v_i * w_jl: λ1 * χ0_j * ξ1_k * E2_dot * v_i * w_jk,\n    # Item 3\n    χ0_j * ξ1_k * ξ1_l * E3 * v_i * v_k * w_jl : χ0_j * ξ1_k * ξ1_l * E3 * v_i * (v_k * w_jl + v_l * w_jk) / 2,\n    # Item 4\n    E2_dot * v_i * v_j: E_dot_ij,\n    E2_ddot * v_i * v_j : E_ddot_ij - E2_dot * v_i * w_jλ - E2_dot * v_j * w_iλ,\n    E3 * v_i * v_j * v_k: E_ijk,\n    E3_dot * v_i * v_j * v_k : E_dot_ijk - E2_dot * v_i * w_jk - E2_dot * v_j * w_ik - E2_dot * v_k * w_ij,\n    E4 * v_i * v_j * v_k * v_l: E_ijkl - E3 * v_i * v_j * w_kl - E3 * v_i * v_k * w_jl - E3 * v_i * v_l * w_jk,\n    # Item 5\n    E3 * v_i * v_j * w_kλ: -E2 * w_ij * w_kλ,\n    E3 * v_i * v_k * w_jλ: -E2 * w_ik * w_jλ,\n    E2_dot * v_i * w_jλ: -E2 * w_iλ * w_jλ,\n    E2_dot * v_j * w_iλ: -E2 * w_iλ * w_jλ,\n    E2_dot * v_j * w_ik: -E2 * w_jλ * w_ik,\n    E2_dot * v_k * w_ij: -E2 * w_kλ * w_ij\n}).expand()\n\nrhs = (2 * rhs_raw).subs({\n    v_i * w_jλ: 0,\n    v_i * w_jl: 0,\n    v_i * v_j * χ0_j: χ0_i,\n    v_i * v_j * χ1_j: χ1_i\n})\n\nlsk.display_latex_equation(lhs, rhs)\n\n\n\\(\\displaystyle E_{ijkl} {\\order[0]{\\chi_{j}}} {\\order[1]{\\xi_{k}}} {\\order[1]{\\xi_{l}}} + E_{ijk} {\\order[0]{\\chi_{j}}} {\\order[2]{\\xi_{k}}} + 2 E_{ijk} {\\order[1]{\\chi_{j}}} {\\order[1]{\\xi_{k}}} + \\ddot{E}_{ij} {\\order[0]{\\chi_{j}}} {\\order[1]{\\lambda}}^{2} + 2 \\dot{E}_{ijk} {\\order[0]{\\chi_{j}}} {\\order[1]{\\lambda}} {\\order[1]{\\xi_{k}}} + \\dot{E}_{ij} {\\order[0]{\\chi_{j}}} {\\order[2]{\\lambda}} + 2 \\dot{E}_{ij} {\\order[1]{\\chi_{j}}} {\\order[1]{\\lambda}}={\\order[0]{\\chi_{i}}} {\\order[2]{\\alpha}} + 2 {\\order[1]{\\alpha}} {\\order[1]{\\chi_{i}}}\\)\n\n\nwhich upon reordering delivers Eq. (3.7)."
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "References",
    "section": "",
    "text": "Chakrabarti, Aditi, Serge Mora, Franck Richard, Ty Phou, Jean-Marc\nFromental, Yves Pomeau, and Basile Audoly. 2018. “Selection of\nHexagonal Buckling Patterns by the Elastic Rayleigh-Taylor\nInstability.” Journal of the Mechanics and Physics of\nSolids 121 (December): 234–57. https://doi.org/10.1016/j.jmps.2018.07.024.\n\n\nKoiter, W. T., and A. M. A. van der Heijden. 2009. W.T.\nKoiter’s Elastic Stability of Solids and Structures.\nCambridge ; New York: Cambridge University\nPress.\n\n\nKoiter, Warner Tjardus. 1945. “The Stability of\nElastic Equilibrium.” PhD thesis,\nDelft: Technische Hooge School Delft.\n\n\nNguyen, Quoc-Son. 2000. Stabilité et mécanique non\nlinéaire. Paris: Hermès Science\nPublications.\n\n\nPotier-Ferry, Michel. 1987. “Foundations of Elastic Postbuckling\nTheory.” In Buckling and Post-Buckling,\n1–82. Lecture Notes in Physics.\nSpringer, Berlin, Heidelberg. https://doi.org/10.1007/BFb0009197.\n\n\nTriantafyllidis, Nicolas. 2017. “Stability of Solids: From\nStructures to Materials.” Lecture Notes. Palaiseau,\nFrance: École polytechnique."
  }
]